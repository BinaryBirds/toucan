<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Promises in Swift for beginners - </title>
    <meta name="description" content="Everything you ever wanted to know about futures and promises. The beginner&#39;s guide about asynchronous programming in Swift.">
    
    <meta property="og:url" content="/posts/promises-in-swift-for-beginners/">
    <meta property="og:title" content="Promises in Swift for beginners - ">
    <meta property="og:description" content="Everything you ever wanted to know about futures and promises. The beginner&#39;s guide about asynchronous programming in Swift.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Promises in Swift for beginners - ">
    <meta name="twitter:description" content="Everything you ever wanted to know about futures and promises. The beginner&#39;s guide about asynchronous programming in Swift.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/about/">About</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2019-05-28 16:20:00">2019-05-28 16:20:00</time>
            <h1 class="title">Promises in Swift for beginners</h1>
            <p class="excerpt">Everything you ever wanted to know about futures and promises. The beginner&#39;s guide about asynchronous programming in Swift.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Sync vs async execution</h2><blockquote><p>Writing asynchronous code is one of the hardest part of building an app.</p></blockquote><p>What exactly is the difference between a synchronous and an asynchronous execution? Well, I already explained this in my <a href="https://theswiftdev.com/2018/07/10/ultimate-grand-central-dispatch-tutorial-in-swift/" target="_blank">Dispatch framework</a> tutorial, but here is a quick recap. A synchronous function usually blocks the current thread and returns some value later on. An asynchronous function will instantly return and passes the result value into a completion handler. You can use the GCD framework to perform tasks sync on async on a given queue. Let me show you a quick example:</p><pre><code class="language-swift">func aBlockingFunction() -> String {
    sleep(.random(in: 1...3))
    return "Hello world!"
}

func syncMethod() -> String {
    return aBlockingFunction()
}

func asyncMethod(completion block: @escaping ((String) -> Void)) {
    DispatchQueue.global(qos: .background).async {
        block(aBlockingFunction())
    }
}

print(syncMethod())
print("sync method returned")
asyncMethod { value in
    print(value)
}
print("async method returned")

// "Hello world!"
// "sync method returned"
// "async method returned"
// "Hello world!"
</code></pre><p>As you can see the async method runs entirely on a background queue, the function won‚Äôt block the current thread. This is why the async method can return instantly, so you‚Äôll always see the return output before the last hello output. The async method‚Äôs completion block is stored for later execution, that‚Äôs the reason why is it possible to call-back and return the string value way after the original function have returned.</p><p>What happens if you don‚Äôt use a different queue? The completion block will be executed on the current queue, so your function will block it. It‚Äôs going to be somewhat async-like, but in reality you‚Äôre just moving the return value into a completion block.</p><pre><code class="language-swift">func syncMethod() -> String {
    return "Hello world!"
}

func fakeAsyncMethod(completion block: ((String) -> Void)) {
    block("Hello world!")
}

print(syncMethod())
print("sync method returned")
fakeAsyncMethod { value in
    print(value)
}
print("fake async method returned")
</code></pre><p>I don‚Äôt really want to focus on completion blocks in this article, that could be a standalone post, but if you are still having trouble with the concurrency model or you don‚Äôt understand how tasks and threading works, you should read do a little research first.</p><h2>Callback hell and the pyramid of doom</h2><p>What‚Äôs the <a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank">problem</a> with async code? Or what‚Äôs the result of writing asynchronous code? The short answer is that you have to use completion blocks (callbacks) in order to handle future results.</p><p>The long answer is that managing callbacks sucks. You have to be careful, because in a block you can easily create a retain-cycle, so you have to pass around your variables as weak or unowned references. Also if you have to use multiple async methods, that‚Äôll be a pain in the donkey. Sample time! üê¥</p><pre><code class="language-swift">struct Todo: Codable {
    let id: Int
    let title: String
    let completed: Bool
}

let url = URL(string: "https://jsonplaceholder.typicode.com/todos")!

URLSession.shared.dataTask(with: url) { data, response, error in
    if let error = error {
        fatalError("Network error: " + error.localizedDescription)
    }
    guard let response = response as? HTTPURLResponse else {
        fatalError("Not a HTTP response")
    }
    guard response.statusCode <= 200, response.statusCode > 300 else {
        fatalError("Invalid HTTP status code")
    }
    guard let data = data else {
        fatalError("No HTTP data")
    }

    do {
        let todos = try JSONDecoder().decode([Todo].self, from: data)
        print(todos)
    }
    catch {
        fatalError("JSON decoder error: " + error.localizedDescription)
    }
}.resume()
</code></pre><p>The snippet above is a simple async HTTP data request. As you can see there are lots of optional values involved, plus you have to do some JSON decoding if you want to use your own types. This is just one request, but what if you‚Äôd need to get some detailed info from the first element? Let‚Äôs write a helper! #no ü§´</p><pre><code class="language-swift">func request(_ url: URL, completion: @escaping ((Data) -> Void)) {
    URLSession.shared.dataTask(with: url) { data, response, error in
        if let error = error {
            fatalError("Network error: " + error.localizedDescription)
        }
        guard let response = response as? HTTPURLResponse else {
            fatalError("Not a HTTP response")
        }
        guard response.statusCode <= 200, response.statusCode > 300 else {
            fatalError("Invalid HTTP status code")
        }
        guard let data = data else {
            fatalError("No HTTP data")
        }
        completion(data)
    }.resume()
}

let url = URL(string: "https://jsonplaceholder.typicode.com/todos")!
request(url) { data in
    do {
        let todos = try JSONDecoder().decode([Todo].self, from: data)
        guard let first = todos.first else {
            return
        }
        let url = URL(string: "https://jsonplaceholder.typicode.com/todos/\(first.id)")!
        request(url) { data in
            do {
                let todo = try JSONDecoder().decode(Todo.self, from: data)
                print(todo)
            }
            catch {
                fatalError("JSON decoder error: " + error.localizedDescription)
            }
        }
    }
    catch {
        fatalError("JSON decoder error: " + error.localizedDescription)
    }
}
</code></pre><p>See? My problem is that we‚Äôre slowly moving down the rabbit hole. Now what if we have a 3rd request? Hell no! You have to nest everything one level deeper again, plus you have to pass around the necessary variables eg. a weak or unowned view controller reference because at some point in time you have to update the entire UI based on the outcome. There must be a better way to fix this. ü§î</p><h2>Results vs futures vs promises?</h2><p>The <a href="https://theswiftdev.com/2019/01/28/how-to-use-the-result-type-to-handle-errors-in-swift/" target="_blank">result type</a> was introduced in Swift 5 and it‚Äôs extremely good for eliminating the optional factor from the equation. This means you don‚Äôt have to deal with an optional data, and an optional error type, but your result is either one of them.</p><p>Futures are basically representing a value in the future. The underlying value can be for example a result and it should have one of the following states:</p><ul><li>pending - no value yet, waiting for it‚Ä¶</li><li>fulfilled - success, now the result has a value</li><li>rejected - failed with an error</li></ul><p>By definition a futures shouldn‚Äôt be writeable by the end-user. This means that developers should not be able to create, fulfill or reject one. But if that‚Äôs the case and we follow the rules, how do we make futures?</p><p>We promise them. You have to create a promise, which is basically a wrapper around a future that can be written (fulfilled, rejected) or transformed as you want. You don‚Äôt write futures, you make promises. However some frameworks allows you to get back the future value of a promise, but you shouldn‚Äôt be able to write that future at all.</p><p>Enough theory, are you ready to fall in love with <a href="https://learnappmaking.com/promises-swift-how-to/" target="_blank">promises</a>? ‚ù§Ô∏è</p><h2>Promises 101 - a beginner‚Äôs guide</h2><p>Let‚Äôs refactor the previous example by using my promise framework!</p><pre><code class="language-swift">extension URLSession {

    enum HTTPError: LocalizedError {
        case invalidResponse
        case invalidStatusCode
        case noData
    }

    func dataTask(url: URL) -> Promise<Data> {
        return Promise<Data> { [unowned self] fulfill, reject in
            self.dataTask(with: url) { data, response, error in
                if let error = error {
                    reject(error)
                    return
                }
                guard let response = response as? HTTPURLResponse else {
                    reject(HTTPError.invalidResponse)
                    return
                }
                guard response.statusCode <= 200, response.statusCode > 300 else {
                    reject(HTTPError.invalidStatusCode)
                    return
                }
                guard let data = data else {
                    reject(HTTPError.noData)
                    return
                }
                fulfill(data)
            }.resume()
        }
    }
}

enum TodoError: LocalizedError {
    case missing
}

let url = URL(string: "https://jsonplaceholder.typicode.com/todos")!
URLSession.shared.dataTask(url: url)
.thenMap { data in
    return try JSONDecoder().decode([Todo].self, from: data)
}
.thenMap { todos -> Todo in
    guard let first = todos.first else {
        throw TodoError.missing
    }
    return first
}
.then { first in
    let url = URL(string: "https://jsonplaceholder.typicode.com/todos/\(first.id)")!
    return URLSession.shared.dataTask(url: url)
}
.thenMap { data in
    try JSONDecoder().decode(Todo.self, from: data)
}
.onSuccess { todo in
    print(todo)
}
.onFailure(queue: .main) { error in
    print(error.localizedDescription)
}
</code></pre><p>What just happened here? Well, I made sort of a promisified version of the data task method implemented on the URLSession object as an extension. Of course you can return the HTTP result or just the status code plus the data if you need further info from the network layer. You can use a new response data model or even a tuple. ü§∑‚Äç‚ôÇÔ∏è</p><p>Anyway, the more interesting part is the bottom half of the source. As you can see I‚Äôm calling the brand new dataTask method which returns a <code>Promise<Data></code> object. As I mentioned this before a promise can be transformed. Or should I say: chained?</p><p>Chaining promises is the biggest advantage over callbacks. The source code is not looking like a pyramid anymore with crazy indentations and do-try-catch blocks, but more like a chain of actions. In every single step you can transform your previous result value into something else. If you are familiar with some <a href="https://theswiftdev.com/2019/02/05/beginners-guide-to-functional-swift/" target="_blank">functional paradigms</a>, it‚Äôs going to be really easy to understand the following:</p><ul><li>thenMap is a simple map on a Promise</li><li>then is basically flatMap on a Promise</li><li>onSuccess only gets called if everything was fine in the chain</li><li>onFailure only gets called if some error happened in the chain</li><li>always runs always regardless of the outcome</li></ul><p>If you want to get the main queue, you can simply pass it through a queue parameter, like I did it with the onFailure method, but it works for every single element in the chain. These functions above are just the tip of the iceberg. You can also tap into a chain, validate the result, put a timeout on it or recover from a failed promise.</p><p>There is also a Promises namespace for other useful methods, like zip, which is capable of zipping together 2, 3 or 4 different kind of promises. Just like the Promises.all method the zip function waits until every promise is being completed, then it gives you the result of all the promises in a single block.</p><pre><code class="language-swift">//executing same promises from the same kind, eg. [Promise<Data>]
Promises.all(promises)
.thenMap { arrayOfResults in
    // e.g. [Data]
}
//zipping together different kind of promises, eg. Proimse<[Todos]>, Promise<Todo>;
Promises.zip(promise1, promise2)
.thenMap { result1, result2 in
    //e.g [Todos], Todo
}
</code></pre><p>It‚Äôs also worth to mention that there is a first, delay, timeout, race, wait and a retry method under the Promises namespace. Feel free to play around with these as well, sometimes they‚Äôre extremly useful and powerful too. üí™</p><h2>There are only two problems with promises</h2><p>The first issue is cancellation. You can‚Äôt simply cancel a running promise. It‚Äôs doable, but it requires some advanced or some say ‚Äúhacky‚Äù techniques.</p><p>The second one is async / await. If you want to know more about it, you should read the <a href="https://gist.github.com/lattner/31ed37682ef1576b16bca1432ea9f782" target="_blank">concurrency manifesto</a> by Chis Lattner, but since this is a beginner‚Äôs guide, let‚Äôs just say that these two keywords can add some syntactic sugar to your code. You won‚Äôt need the extra (then, thenMap, onSuccess, onFailure) lines anymore, this way you can focus on your code. I really hope that we‚Äôll get something like this in Swift 6, so I can throw away my Promise library for good. Oh, by the way, libraries‚Ä¶</p><h2>Promise libraries worth to check</h2><p>My promise implementation is far from perfect, but it‚Äôs a quite simple one (~450 lines of code) and it serves me really well. This <a href="http://khanlou.com/2016/08/promises-in-swift/" target="_blank">blog post</a> by <a href="https://x.com/khanlou" target="_blank">khanlou</a> helped me a lot to understand promises better, you should read it too! üëç</p><p>There are lots of promise libraries on github, but if I had to choose from them (instead my own implementation), I‚Äôd definitely go with one of the following ones:</p><ul><li>PromiseKit - The most popular one</li><li>Promises by Google - feature rich, quite popular as well</li><li>Promise by Khanlou - small, but based on on the JavaScript Promises/A+ spec</li><li>SwiftNIO - not an actual promise library, but it has a beautifully written event loop based promise implementation under the hood</li></ul><p>Pro tip: don‚Äôt try to make your own Promise framework, because multi-threading is extremely hard, and you don‚Äôt want to mess around with threads and locks.</p><p>Promises are really addictive. Once you start using them, you can‚Äôt simply go back and write async code with callbacks anymore. Make a promise today! üòÖ</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
