<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>How to build SwiftUI apps using VIPER? - </title>
    <meta name="description" content="In this tutorial I&#39;ll show you how to combine SwiftUI with the VIPER architecture in a real world iOS application example.">
    
    <meta property="og:url" content="/posts/how-to-build-swiftui-apps-using-viper/">
    <meta property="og:title" content="How to build SwiftUI apps using VIPER? - ">
    <meta property="og:description" content="In this tutorial I&#39;ll show you how to combine SwiftUI with the VIPER architecture in a real world iOS application example.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="How to build SwiftUI apps using VIPER? - ">
    <meta name="twitter:description" content="In this tutorial I&#39;ll show you how to combine SwiftUI with the VIPER architecture in a real world iOS application example.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2019-09-18 16:20:00">2019-09-18 16:20:00</time>
            <h1 class="title">How to build SwiftUI apps using VIPER?</h1>
            <p class="excerpt">In this tutorial I&#39;ll show you how to combine SwiftUI with the VIPER architecture in a real world iOS application example.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>SwiftUI - the new kid on the block</h2><p>There are literally hundreds of SwiftUI tutorials around the web, but I was only able to find just one or two that focuses on <a href="https://mecid.github.io/2019/06/05/swiftui-making-real-world-app/" target="_blank">real world</a> use cases instead of the smaller details like how to configure / make X in SwiftUI. Nice tutorials <a href="https://x.com/mecid" target="_blank">@mecid</a> keep it up!</p><p>I also had my own ‚Äústruggle‚Äù with SwiftUI, because <a href="https://theswiftdev.com/2019/05/23/building-input-forms-for-ios-apps/" target="_blank">my collection view framework</a> is structured exactly the same way as you write SwiftUI code. After WWDC I was like, hell no! I‚Äôm doing the same method for months now, so why should I care? I started to believe that some Apple engineers are reading my blog. üòÇ</p><p>Anyway I knew at day zero that a crazy amount of new SwiftUI tutorials will arrive and everyone will be hyped about the new declarative UI framework, but honestly I already had my universal toolkit for this purpose. That‚Äôs why I don‚Äôt wanted to write about it. Honestly I still love Combine much more than SwiftUI. I‚Äôm also quite disappointed since CollectionView is completely missing from the framework.</p><p>Finally, just because what the heck lets try new things and I was curious about how SwiftUI can fit into my app building methodology I started to create a new VIPER template based on those kind of views. I also wanted to make a useful, scalable, modular real world application example using the new framework, which is up-to-date. A lot has changed in SwiftUI during the Xcode 11 beta period, so that‚Äôs why I‚Äôm only publishing this tutorial now. Enough chatter, shouldn‚Äôt we code already? üòõ</p><h2>Learn a modern VIPER architecture</h2><p>I‚Äôve spent my last two years using the VIPER architecture. Some people say ‚Äúit‚Äôs way too complex‚Äù or ‚Äúit‚Äôs not a good fit for small teams‚Äù. I can only tell them one word:</p><blockquote><p>Bullshit!</p></blockquote><p>I believe that I‚Äôve created a modern & relatively simple pattern that can be used for literally anything. Learning VIPER will definitely improve your code quality thanks to the clean architecture and the SOLID principles. You‚Äôll have a better understanding of how smaller pieces can work together and communicate with each other.</p><p>Isolated smaller components can speed up development, because you just have to work on a little piece at once, plus you can create tests for that particular thing, which is a huge win for testability & code coverage (you don‚Äôt have to run your app all the time if you want to test something, you can work on the module you just need).</p><p>I‚Äôm usually working with a really simple code generator to fire up new modules, this way I can save a lot of time. If you have to work alone on a project the module generator and the predefined structure can even save you some more time. Also you really can‚Äôt mess up things or end up with massive files if you are following the basic VIPER rules. I‚Äôll teach you my method in about 10 minutes. ‚è∞</p><h2>What the heck is VIPER anyway?</h2><p>If you never heard about VIPER before, the first thing you should know is that a VIPER module contains the following components:</p><ul><li>View = UIViewController subclass or SwiftUI View</li><li>Interactor = Provides the required data in the proper format</li><li>Presenter = UI independent business logic (what to do exactly)</li><li>Entity = Data objects (sometimes it‚Äôs missing from the module)</li><li>Router = Builds up the view controller hierarchy (show, present, dismiss, etc)</li></ul><p>I always have a module file next to these ones where I define a module builder which builds up the whole thing from the components above and in that file I also define the module specific protocols. I usually name these protocols as interfaces they make it possible that any of the components can be replaced using <a href="https://theswiftdev.com/2018/07/17/swift-dependency-injection-design-pattern/" target="_blank">dependency injection</a>. This way we can test anything by using mocked objects in our unit tests.</p><blockquote><p>NOTE: Some say that a VIPER module with a Builder is called VIPER/B. I think the module file is an ideal place to store your module builder object, the module interfaces and the module delegate if you need one.</p></blockquote><h2>Protocol oriented VIPER architecture</h2><p>So the key is the 6 main protocol that connects View-Interactor-Presenter-Router. These protocols ensure that none of the VIPER components can see more than it‚Äôs required. If you go back to <a href="https://theswiftdev.com/2018/03/12/the-ultimate-viper-architecture-tutorial/" target="_blank">my first tutorial</a> you‚Äôll see that I made a mistake there. The thing is that you can call a method on the router through the presenter from the view, which is bad. This new approach fixes that issue. üêõ</p><pre><code>View-to-Presenter
Presenter-to-View

Router-to-Presenter
Presenter-to-Router

Interactor-to-Presenter
Presenter-to-Interactor


Module
# ---
builds up pointers and returns a UIViewController


View implements View-to-Presenter
# ---
strong presenter as Presenter-to-View-interface


Presenter implements Presenter-to-Router, Presenter-to-Interactor, Presenter-to-View
# ---
strong router as Router-to-Presenter-interface
strong interactor as Interactor-to-Presenter-interface
weak view as View-to-Presenter-interface


Interactor implements Interactor-to-Presenter
# ---
weak presenter as Presenter-to-Interactor-interface


Router implemenents Presenter-to-Router
# ---
weak presenter as Presenter-to-Router-interface
</code></pre><p>As you can see the view (which can be a <code>UIViewController</code> subclass) holds the presenter strongly and the presenter will retain the interactor and router classes. Everything else is a weak pointer, because we don‚Äôt like retain cycles. It might seems a little bit complicated at first sight, but after writing your first few modules you‚Äôll see how nice is to separate logical components from each other. üêç</p><p>Please note that not everything is a VIPER module. Don‚Äôt try to write your API communication layer or a CoreLocation service as a module, because those kind of stuff are standalone let‚Äôs say: services. I‚Äôll write about them in the next one, but for now let‚Äôs just focus on the anatomy of a VIPER module.</p><h2>Generic VIPER implementation in Swift 5</h2><p>Are you ready to write some Swift code? All right, let‚Äôs create some generic VIPER interfaces that can be extended later on, don‚Äôt be afraid won‚Äôt be that hard. üòâ</p><pre><code class="language-swift">// MARK: - interfaces

public protocol RouterPresenterInterface: class {

}

public protocol InteractorPresenterInterface: class {

}

public protocol PresenterRouterInterface: class {

}

public protocol PresenterInteractorInterface: class {

}

public protocol PresenterViewInterface: class {

}

public protocol ViewPresenterInterface: class {

}

// MARK: - viper

public protocol RouterInterface: RouterPresenterInterface {
    associatedtype PresenterRouter

    var presenter: PresenterRouter! { get set }
}

public protocol InteractorInterface: InteractorPresenterInterface {
    associatedtype PresenterInteractor

    var presenter: PresenterInteractor! { get set }
}

public protocol PresenterInterface: PresenterRouterInterface & PresenterInteractorInterface & PresenterViewInterface {
    associatedtype RouterPresenter
    associatedtype InteractorPresenter
    associatedtype ViewPresenter

    var router: RouterPresenter! { get set }
    var interactor: InteractorPresenter! { get set }
    var view: ViewPresenter! { get set }
}

public protocol ViewInterface: ViewPresenterInterface {
    associatedtype PresenterView

    var presenter: PresenterView! { get set }
}

public protocol EntityInterface {

}

// MARK: - module

public protocol ModuleInterface {

    associatedtype View where View: ViewInterface
    associatedtype Presenter where Presenter: PresenterInterface
    associatedtype Router where Router: RouterInterface
    associatedtype Interactor where Interactor: InteractorInterface

    func assemble(view: View, presenter: Presenter, router: Router, interactor: Interactor)
}

public extension ModuleInterface {

    func assemble(view: View, presenter: Presenter, router: Router, interactor: Interactor) {
        view.presenter = (presenter as! Self.View.PresenterView)

        presenter.view = (view as! Self.Presenter.ViewPresenter)
        presenter.interactor = (interactor as! Self.Presenter.InteractorPresenter)
        presenter.router = (router as! Self.Presenter.RouterPresenter)

        interactor.presenter = (presenter as! Self.Interactor.PresenterInteractor)

        router.presenter = (presenter as! Self.Router.PresenterRouter)
    }
}
</code></pre><p>Associated types are just placeholders for specific types, by using a generic interface design I can assemble my modules with a generic module interface extension and if some protocol is missing the app will crash just as I try to initialize the bad module.</p><p>I love this approach, because it saves me from a lot of boilerplate module builder code. Also this way everything will have a base protocol, so I can extend anything in a really neat protocol oriented way. Anyway if you don‚Äôt understand generics that‚Äôs not a big deal, in the actual module implementation you will barely meet them.</p><p>So how does an actual module looks like?</p><pre><code class="language-swift">// TodoModule.swift

// MARK: - router

protocol TodoRouterPresenterInterface: RouterPresenterInterface {

}

// MARK: - presenter

protocol TodoPresenterRouterInterface: PresenterRouterInterface {

}

protocol TodoPresenterInteractorInterface: PresenterInteractorInterface {

}

protocol TodoPresenterViewInterface: PresenterViewInterface {

}

// MARK: - interactor

protocol TodoInteractorPresenterInterface: InteractorPresenterInterface {

}

// MARK: - view

protocol TodoViewPresenterInterface: ViewPresenterInterface {

}


// MARK: - module builder

final class TodoModule: ModuleInterface {

    typealias View = TodoView
    typealias Presenter = TodoPresenter
    typealias Router = TodoRouter
    typealias Interactor = TodoInteractor

    func build() -> UIViewController {
        let view = View()
        let interactor = Interactor()
        let presenter = Presenter()
        let router = Router()

        self.assemble(view: view, presenter: presenter, router: router, interactor: interactor)

        router.viewController = view

        return view
    }
}


// TodoPresenter.swift

final class TodoPresenter: PresenterInterface {
    var router: TodoRouterPresenterInterface!
    var interactor: TodoInteractorPresenterInterface!
    weak var view: TodoViewPresenterInterface!
}

extension TodoPresenter: TodoPresenterRouterInterface {

}

extension TodoPresenter: TodoPresenterInteractorInterface {

}

extension TodoPresenter: TodoPresenterViewInterface {

}

// TodoInteractor.swift

final class TodoInteractor: InteractorInterface {
    weak var presenter: TodoPresenterInteractorInterface!
}

extension TodoInteractor: TodoInteractorPresenterInterface {

}

// TodoRouter.swift

final class TodoRouter: RouterInterface {
    weak var presenter: TodoPresenterRouterInterface!
    weak var viewController: UIViewController?
}

extension TodoRouter: TodoRouterPresenterInterface {

}

// TodoView.swift

final class TodoView: UIViewController, ViewInterface {
    var presenter: TodoPresenterViewInterface!
}

extension TodoView: TodoViewPresenterInterface {

}
</code></pre><p>A VIPER module is made from five files, which is a huge improvement compared to my old method (I used 9 files for a single module, which is still better than a 2000 lines of code massive view controller, but yeah it was quite many files‚Ä¶ üòÇ ).</p><p>You can use my <a href="https://github.com/corekit/viper" target="_blank">VIPER protocol library</a> if you want or simply copy & paste these interfaces to your project. I also have a <a href="https://github.com/corekit/vipera" target="_blank">module generator</a> written entirely in Swift that can generate a module based on this template (or you can make your own).</p><h2>How to build VIPER interfaces?</h2><p>Let me explain a sample flow real quick, consider the following example:</p><pre><code class="language-swift">protocol TodoRouterPresenterInterface: RouterPresenterInterface {
    func dismiss()
}

// MARK: - presenter

protocol TodoPresenterRouterInterface: PresenterRouterInterface {

}

protocol TodoPresenterInteractorInterface: PresenterInteractorInterface {
    func didLoadWelcomeText(_ text: String)
}

protocol TodoPresenterViewInterface: PresenterViewInterface {
    func ready()
    func close()
}

// MARK: - interactor

protocol TodoInteractorPresenterInterface: InteractorPresenterInterface {
    func startLoadingWelcomeText()
}

// MARK: - view

protocol TodoViewPresenterInterface: ViewPresenterInterface {
    func setLoadingIndicator(visible: Bool)
    func setWelcomeText(_ text: String)
}
</code></pre><p>The view calls <code>ready()</code> on the presenter at some point in time <code>viewDidLoad()</code>, so the presenter can kick off. First it tells the view to show the loading indicator by calling setLoadingIndicator(visible: true), next asks the interactor to load the welcome text asynchronously <code>startLoadingWelcomeText()</code>. After the data arrives back to the interactor it can notify the presenter by using the <code>didLoadWelcomeText("")</code> method. The presenter can now tell the view to hide the loading indicator using the same method <code>setLoadingIndicator(visible: false)</code> this time with a false parameter and to display the welcome text by using <code>setWelcomeText("")</code>.</p><p>Another use case is that someone taps a button on the view in order to close the controller. The view calls <code>close()</code> on the presenter, and the presenter can simply call dismiss() on the router. The presenter can also do some other stuff (like cleaning up some resources) before it asks the router to dismiss the view controller.</p><p>I hope that you get the example, feel fee to implement everything by your own, it‚Äôs quite a nice task to practice. Of course you can utilize blocks, promises or the brand new Combine framework to make your live more easy. You can for example auto-notify the presenter if some async data loading have finished. üòâ</p><p>So now that you have a basic understanding about a modern VIPER architecture lets talk about how to replace the traditional ViewController subclass with SwiftUI.</p><h2>How to design a VIPER based SwiftUI application?</h2><p>SwiftUI is quite a unique beast. View are structs so our generic VIPER protocol needs some alterations in order to make everything work.</p><p>The first thing you have to do is to get rid of the ViewPresenterInterface protocol. Next you can remove the view property from the PresenterInterface since we‚Äôre going to use an observable view-model pattern to auto-update the view with data. The last modification is that you have to remove the view parameter from the default implementation of the assemble function inside the ModuleInterface extension.</p><p>So I mentioned a view-model, let‚Äôs make one. For the sake of simplicity I‚Äôm going to use an error Bool to indicate if something went wrong, but you could use another view, or a standalone VIPER module that presents an alert message.</p><pre><code class="language-swift">import Combine
import SwiftUI

final class TodoViewModel: ObservableObject {

    let objectWillChange = ObservableObjectPublisher()

    @Published var error: Bool = false {
        willSet {
            self.objectWillChange.send()
        }
    }

    @Published var todos: [TodoEntity] = [] {
       willSet {
            self.objectWillChange.send()
        }
    }
}
</code></pre><p>This class conforms to the <code>ObservableObject</code> which makes SwiftUI possible to check for updates & re-render the view hierarchy if something changed. You just need a property with the ObservableObjectPublisher type and literally <code>send()</code> a message if something will change this trigger the auto-update in your views. üî•</p><p>The <code>TodoEntity</code> is just a basic struct that conforms to a bunch of protocols like the new Identifiable from SwiftUI, because we‚Äôd like to display entities in a list.</p><pre><code class="language-swift">import Foundation
import SwiftUI

struct TodoEntity: EntityInterface, Codable, Identifiable {
    let id: Int
    let title: String
    let completed: Bool
}
</code></pre><p>A basic SwiftUI view will still implement the <code>ViewInterface</code> and it‚Äôll have a reference to the presenter. Our view-model property is also going to be used here marked with an <code>@ObservedObject</code> property wrapper. This is how it looks like in code so far:</p><pre><code class="language-swift">import SwiftUI

struct TodoView: ViewInterface, View {

    var presenter: TodoPresenterViewInterface!

    @ObservedObject var viewModel: TodoViewModel

    var body: some View {
        Text("SwiftUI ‚ù§Ô∏è VIPER")
    }
}
</code></pre><p>The presenter will also have a <code>weak var viewModel: TodoViewModel!</code> reference to be able to update the the view-model. Seems like we have a two-way communication flow between the view and the presenter by using a view-model. Looks good to me. üëç</p><p>We can also utilize the brand new <code>@EnvironmentObject</code> if we want to pass around some data in the view hierarchy. You just have to implement the same observation protocol in your environment object that we did for the view-model. For example:</p><pre><code class="language-swift">import Foundation
import Combine

final class TodoEnvironment: ObservableObject {

    let objectWillChange = ObservableObjectPublisher()

    @Published var title: String = "Todo list" {
       willSet {
            self.objectWillChange.send()
        }
    }
}
</code></pre><p>Finally let me show you how to implement the module builder, because that‚Äôs quite tricky. You have to use the new generic <code>UIHostingController</code>, which is thankfully an <code>UIViewController</code> subclass so you can return it after you finish module building.</p><pre><code class="language-swift">final class TodoModule: ModuleInterface {
    typealias View = TodoView
    typealias Presenter = TodoPresenter
    typealias Router = TodoRouter
    typealias Interactor = TodoInteractor

    func build() -> UIViewController {
        let presenter = Presenter()
        let interactor = Interactor()
        let router = Router()

        let viewModel = TodoViewModel()
        let view = View(presenter: presenter, viewModel: viewModel)
            .environmentObject(TodoEnvironment())
        presenter.viewModel = viewModel

        self.assemble(presenter: presenter, router: router, interactor: interactor)

        let viewController = UIHostingController(rootView: view)
        router.viewController = viewController
        return viewController
    }
}
</code></pre><p>Putting together the pieces from now is just a piece of cake. If you want, you can challenge yourself to build something without downloading the <a href="https://github.com/theswiftdev/tutorials/tree/master/VIPER/VIPERAndSwiftUI" target="_blank">final project</a>. üç∞</p><p>Well, if you‚Äôre not into challenges that‚Äôs fine too, feel free to grab the example code from The.Swift.Dev tutorials on <a href="https://github.com/theswiftdev/tutorials/" target="_blank">GitHub</a>. It contains a nice interactor with some cool networking stuff <a href="https://theswiftdev.com/2019/08/15/urlsession-and-the-combine-framework/" target="_blank">using URLSession and the Combine framework</a>. The final SwiftUI code is just a rough implementation, because as I told you in the beginning there are really good tutorials about SwiftUI with examples.</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
