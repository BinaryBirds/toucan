<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>How to write Swift scripts using the new Command API in Vapor 4? - </title>
    <meta name="description" content="Shell scripts are essentials on the server side. Learn how to build Swift scripts for your backend apps using property wrappers.">
    
    <meta property="og:url" content="/posts/how-to-write-swift-scripts-using-the-new-command-api-in-vapor-4/">
    <meta property="og:title" content="How to write Swift scripts using the new Command API in Vapor 4? - ">
    <meta property="og:description" content="Shell scripts are essentials on the server side. Learn how to build Swift scripts for your backend apps using property wrappers.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="How to write Swift scripts using the new Command API in Vapor 4? - ">
    <meta name="twitter:description" content="Shell scripts are essentials on the server side. Learn how to build Swift scripts for your backend apps using property wrappers.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/about/">About</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2020-03-03 16:20:00">2020-03-03 16:20:00</time>
            <h1 class="title">How to write Swift scripts using the new Command API in Vapor 4?</h1>
            <p class="excerpt">Shell scripts are essentials on the server side. Learn how to build Swift scripts for your backend apps using property wrappers.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Swift Argument Parser vs Vapor Commands</h2><p>Apple open-sourced a new library that can help you a lot if you want to build scripts that written in Swift. The <a href="https://github.com/apple/swift-argument-parser" target="_blank">Swift Argument Parser</a> was previously part of the Swift Package Manager tools, but now it is even powerful & has it‚Äôs own life (I mean repository). üòâ</p><p>On the other hand Vapor already had a somewhat similar approach to build scripts, but in Vapor 4 the Command API is better than ever. <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md" target="_blank">Property Wrappers</a> (available from Swift 5.1) are used in both cases to handle arguments, flags & options. Personally I like this approach a lot.</p><p>Let me show you a simple hello command:</p><pre><code class="language-swift">// using Argument Parser
import ArgumentParser

struct HelloCommand: ParsableCommand {
    @Argument(help: "The name to say hello")
    var name: String

    func run() throws {
        print("Hello \(self.name)!")
    }
}
HelloCommand.main()
// usage: swift run myProject world
</code></pre><p>Now I‚Äôll show you how to implement a similar command <a href="https://theswiftdev.com/beginners-guide-to-server-side-swift-using-vapor-4/" target="_blank">using Vapor</a>:</p><pre><code class="language-swift">// using Vapor
import Vapor

final class HelloCommand: Command {
    
    let help = "This command will say hello to a given name."

    struct Signature: CommandSignature {
        @Argument(name: "name", help: "The name to say hello")
        var name: String
    }

    func run(using context: CommandContext, signature: Signature) throws {
        print("Hello \(signature.name)!")
    }
}

public func configure(_ app: Application) throws {
    app.commands.use(HelloCommand(), as: "hello")
}
// usage: swift run myProject hello world
</code></pre><p>As you can see they almost look like the same.</p><blockquote><p>NOTE: If you love scripting, you should definitely check <a href="https://github.com/mxcl/swift-sh" target="_blank">swift-sh</a> and <a href="https://github.com/twostraws/Brisk" target="_blank">Brisk</a></p></blockquote><p>The Swift Argument Parser library is a lightweight solution if you are only looking for a simple Swift script. A good example is a tool that manipulates files on the system or something similar. It‚Äôs just one little dependency, but it removes so much boilerplate from your scripts. It allows you to focus on the script itself, instead of parsing the command line inputs. You can find more detailed examples and a detailed <a href="https://github.com/apple/swift-argument-parser/tree/master/Documentation" target="_blank">documentation</a> inside the GitHub repository. üôè</p><p>Vapor‚Äôs Command API is useful if you want to perform more complicated tasks with your scripts. Anything that‚Äôs part of your Vapor application can be triggered from a command, so you can easily create a backend tool that reads (or writes) records from the database <a href="https://theswiftdev.com/a-tutorial-for-beginners-about-the-fluent-postgresql-driver-in-vapor-4/" target="_blank">using Fluent 4</a>. This is the main advantage of using a Vapor command, instead a standalone Swift script.</p><h2>Arguments, options, flags</h2><p>Let‚Äôs extend the hello command with a new option and a flag. The main difference between an option and a flag is that an option has an associated value, but a flag is just something that you give to the command or not. Both options and flags start with a single <code>-</code> or a double dash <code>--</code>, usually the single dashed version uses a short name for the same thing. ü§ì</p><blockquote><p>NOTE: Arguments are user provided values read in order (e.g. <code>./hello joe bob john</code>).</p></blockquote><p>Now that you know the basic definitions, here is the example:</p><pre><code class="language-swift">final class HelloCommand: Command {
        
    struct Signature: CommandSignature {

        @Argument(name: "name", help: "The name to say hello")
        var name: String

        @Option(name: "greeting", short: "g", help: "Greeting used")
        var greeting: String?

        @Flag(name: "capitalize", short: "c", help: "Capitalizes the name")
        var capitalize: Bool
    }

    let help = "This command will say hello to a given name."

    func run(using context: CommandContext, signature: Signature) throws {
        let greeting = signature.greeting ?? "Hello"
        var name = signature.name
        if signature.capitalize {
            name = name.capitalized
        }
        print("\(greeting) \(name)!")
    }
}
</code></pre><p>Arguments are required by default, options and flags are optionals. You can have a custom name (short and long) for everything, plus you can customize the help message for every component.</p><pre><code class="language-sh">swift run Run hello john
# Hello john!

swift run Run hello john --greeting Hi
# Hi john!

swift run Run hello john --greeting Hi --capitalized
# Hi John!

swift run Run hello john -g Szia -c
# Szia John!
</code></pre><p>You can call the command using multiple styles. Feel free to pick a preferred version. ‚≠êÔ∏è</p><h2>Subcommands</h2><blockquote><p>When command-line programs grow larger, it can be useful to divide them into a group of smaller programs, providing an interface through subcommands. Utilities such as git and the Swift package manager are able to provide varied interfaces for each of their sub-functions by implementing subcommands such as git branch or swift package init.</p></blockquote><p>Vapor can handle command groups in a really cool way. I‚Äôll add an extra static property to name our commands, since I don‚Äôt like to repeat myself or bloat the code with unnecessary strings:</p><pre><code class="language-swift">final class HelloCommand: Command {
    
    static var name = "hello"
        
    //...
}

struct WelcomeCommandGroup: CommandGroup {
    
    static var name = "welcome"

    let help: String
    let commands: [String: AnyCommand]
    
    var defaultCommand: AnyCommand? {
        self.commands[HelloCommand.name]
    }

    init() {
        self.help = "SEO command group help"

        self.commands = [
            HelloCommand.name: HelloCommand(),
        ]
    }
}

public func configure(_ app: Application) throws {

    app.commands.use(WelcomeCommandGroup(), as: WelcomeCommandGroup.name)
}
</code></pre><p>That‚Äôs it, we just moved our <code>hello</code> command under the <code>welcome</code> namespace.</p><pre><code class="language-sh">swift run Run welcome hello john --greeting "Hi" --capitalize
</code></pre><p>If you read the Swift Argument Parser docs, you can achieve the exact same behavior through a custom <code>CommandConfiguration</code>. Personally, I prefer Vapor‚Äôs approach here‚Ä¶ ü§∑‚Äç‚ôÇÔ∏è</p><h2>Waiting for async tasks</h2><p>Vapor builds on top of <a href="https://github.com/apple/swift-nio" target="_blank">SwiftNIO</a> including EventLoops, Futures & Promises. Most of the API is asynchronous, but in the CLI world you have to wait for the async operations to finish.</p><pre><code class="language-swift">final class TodoCommand: Command {
    
    static let name = "todo"

    struct Signature: CommandSignature { }
        
    let help = "This command will create a dummy Todo item"

    func run(using context: CommandContext, signature: Signature) throws {
        let app = context.application
        app.logger.notice("Creating todos...")
        
        let todo = Todo(title: "Wait for async tasks...")
        try todo.create(on: app.db).wait()
        
        app.logger.notice("Todo is ready.")
    }
}
</code></pre><p>There is a throwing <code>wait()</code> method that you can utilize to ‚Äústay in the loop‚Äù until everything is done. You can also get a pointer for the application object by using the current context. The app has the database connection, so you can tell Fluent to <a href="https://theswiftdev.com/a-tutorial-for-beginners-about-the-fluent-postgresql-driver-in-vapor-4/" target="_blank">create a new model</a>. Also you can use the built-in logger to print info to the console while the user waits. ‚è≥</p><h2>Using ConsoleKit without Vapor</h2><p>Let‚Äôs talk about overheads. Vapor comes with this neat commands API, but also bundles lots of other core things. What if I just want the goodies for my Swift scripts? No problem. You can use the underlying ConsoleKit by adding it as a dependency.</p><pre><code class="language-swift">// swift-tools-version:5.2
import PackageDescription

let package = Package(
    name: "myProject",
    platforms: [
       .macOS(.v10_15)
    ],
    dependencies: [
        .package(url: "https://github.com/vapor/console-kit", from: "4.1.0"),
    ],
    targets: [
        .target(name: "myProject", dependencies: [
            .product(name: "ConsoleKit", package: "console-kit"),
        ])
    ]
)
</code></pre><p>You still have to do some additional work in your <code>main.swift</code> file, but nothing serious:</p><pre><code class="language-swift">import ConsoleKit
import Foundation

let console: Console = Terminal()
var input = CommandInput(arguments: CommandLine.arguments)
var context = CommandContext(console: console, input: input)

var commands = Commands(enableAutocomplete: true)
commands.use(HelloCommand(), as: HelloCommand.name, isDefault: false)

do {
    let group = commands.group(help: "Using ConsoleKit without Vapor.")
    try console.run(group, input: input)
}
catch {
    console.error("\(error)")
    exit(1)
}
</code></pre><p>This way you can get rid of most of the network related core packages (that are included by default if you use Vapor). This approach only fetches <a href="https://github.com/apple/swift-log" target="_blank">swift-log</a> as a third party dependency. üòç</p><h2>Summary</h2><p>ConsoleKit in Vapor is a great way to write CLI tools and small scripts. The new Swift Argument Parser is a more lightweight solution for the same problem. If your plan is to maintain databases through scripts or you perform lots of networking or asynchronous operations it might be better to go with Vapor, since you can always grow by importing a new component from the ecosystem.</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
