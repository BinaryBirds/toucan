<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Lenses and prisms in Swift - </title>
    <meta name="description" content="Beginner&#39;s guide about optics in Swift. Learn how to use lenses and prisms to manipulate objects using a functional approach.">
    
    <meta property="og:url" content="/posts/lenses-and-prisms-in-swift/">
    <meta property="og:title" content="Lenses and prisms in Swift - ">
    <meta property="og:description" content="Beginner&#39;s guide about optics in Swift. Learn how to use lenses and prisms to manipulate objects using a functional approach.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Lenses and prisms in Swift - ">
    <meta name="twitter:description" content="Beginner&#39;s guide about optics in Swift. Learn how to use lenses and prisms to manipulate objects using a functional approach.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/about/">About</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2022-08-12 16:20:00">2022-08-12 16:20:00</time>
            <h1 class="title">Lenses and prisms in Swift</h1>
            <p class="excerpt">Beginner&#39;s guide about optics in Swift. Learn how to use lenses and prisms to manipulate objects using a functional approach.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Understanding optics</h2><p>Optics is a pattern borrowed from <a href="https://en.wikipedia.org/wiki/Haskell" target="_blank">Haskell</a>, that enables you to zoom down into objects. In other words, you can set or get a property of an object in a functional way. By functional I mean you can set a property without causing mutation, so instead of altering the original object, a new one will be created with the updated property. Trust me it‚Äôs not that complicated as it might sounds. üòÖ</p><p>We‚Äôre going to need just a bit of Swift code to understand everything.</p><pre><code class="language-swift">struct Address {
    let street: String
    let city: String
}

struct Company {
    let name: String
    let address: Address
}

struct Person {
    let name: String
    let company: Company
}
</code></pre><p>As you can see it is possible to build up a hierarchy using these structs. A person can have a company and the company has an address, for example:</p><pre><code class="language-swift">let oneInfiniteLoop = Address(street: "One Infinite Loop", city: "Cupertino")
let appleInc = Company(name: "Apple Inc.", address: oneInfiniteLoop)
let steveJobs = Person(name: "Steve Jobs", company: appleInc)
</code></pre><p>Now let‚Äôs imagine that the street name of the address changes, how do we alter this one field and propagate the property change for the entire structure? ü§î</p><pre><code class="language-swift">struct Address {
    var street: String
    let city: String
}

struct Company {
    let name: String
    var address: Address
}

struct Person {
    let name: String
    var company: Company
}

var oneInfiniteLoop = Address(street: "One Infinite Loop", city: "Cupertino")
var appleInc = Company(name: "Apple Inc.", address: oneInfiniteLoop)
var steveJobs = Person(name: "Steve Jobs", company: appleInc)

oneInfiniteLoop.street = "Apple Park Way"
appleInc.address = oneInfiniteLoop
steveJobs.company = appleInc

print(steveJobs) // address is updated
</code></pre><p>In order to update the street property we had to do quite a lot of work, first we had to change some of the properties to variables, and we also had to manually update all the references, since structs are not reference types, but value types, hence copies are being used all around.</p><p>This looks really bad, we‚Äôve also caused quite a lot of mutation and now others can also change these variable properties, which we don‚Äôt necessary want. Is there a better way? Well‚Ä¶</p><pre><code class="language-swift">let newSteveJobs = Person(name: steveJobs.name,
                      company: Company(name: appleInc.name,
                                       address: Address(street: "Apple Park Way",
                                                        city: oneInfiniteLoop.city)))
</code></pre><p>Ok, this is ridiculous, can we actually do something better? üôÑ</p><h2>Lenses</h2><p>We can use a <a href="https://chris.eidhof.nl/post/lenses-in-swift/" target="_blank">lens</a> to zoom on a property and use that lens to construct complex types. A lens is a value representing maps between a complex type and one of its property.</p><p>Let‚Äôs keep it simple and define a Lens struct that can transform a whole object to a partial value using a getter, and set the partial value on the entire object using a setter, then return a new ‚Äúwhole object‚Äù. This is how the lens definition looks like in Swift.</p><pre><code class="language-swift">struct Lens<Whole, Part> {
    let get: (Whole) -> Part
    let set: (Part, Whole) -> Whole
}
</code></pre><p>Now we can create a <a href="https://te.xel.io/posts/2016-04-30-lambda-fu-powerup-lenses-prisms-and-optics-with-swift.html" target="_blank">lens that zooms</a> on the street property of an address and construct a new address using an existing one.</p><pre><code class="language-swift">let oneInfiniteLoop = Address(street: "One Infinite Loop", city: "Cupertino")
let appleInc = Company(name: "Apple Inc.", address: oneInfiniteLoop)
let steveJobs = Person(name: "Steve Jobs", company: appleInc)

let addressStreetLens = Lens<Address, String>(get: { $0.street },
                                              set: { Address(street: $0, city: $1.city) })


let newSteveJobs = Person(name: steveJobs.name,
                          company: Company(name: appleInc.name,
                                           address: addressStreetLens.set("Apple Park Way", oneInfiniteLoop)))
</code></pre><p>Let‚Äôs try to build lenses for the other properties as well.</p><pre><code class="language-swift">let oneInfiniteLoop = Address(street: "One Infinite Loop", city: "Cupertino")
let appleInc = Company(name: "Apple Inc.", address: oneInfiniteLoop)
let steveJobs = Person(name: "Steve Jobs", company: appleInc)

let addressStreetLens = Lens<Address, String>(get: { $0.street },
                                              set: { Address(street: $0, city: $1.city) })

let companyAddressLens = Lens<Company, Address>(get: { $0.address },
                                                set: { Company(name: $1.name, address: $0) })

let personCompanyLens = Lens<Person, Company>(get: { $0.company },
                                              set: { Person(name: $1.name, company: $0) })

let newAddress = addressStreetLens.set("Apple Park Way", oneInfiniteLoop)
let newCompany = companyAddressLens.set(newAddress, appleInc)
let newPerson = personCompanyLens.set(newCompany, steveJobs)

print(newPerson)
</code></pre><p>This might looks a bit strange at first sight, but we‚Äôre just scratching the surface here. It is possible to compose lenses and create a transition from an object to another property inside the hierarchy.</p><pre><code class="language-swift">struct Lens<Whole, Part> {
    let get: (Whole) -> Part
    let set: (Part, Whole) -> Whole
}

extension Lens {
    func transition<NewPart>(_ to: Lens<Part, NewPart>) -> Lens<Whole, NewPart> {
        .init(get: { to.get(get($0)) },
              set: { set(to.set($0, get($1)), $1) })
    }

}

// ...

let personStreetLens = personCompanyLens.transition(companyAddressLens)
                                        .transition(addressStreetLens)


let newPerson = personStreetLens.set("Apple Park Way", steveJobs)

print(newPerson)
</code></pre><p>So in our case we can come up with a transition method and create a lens between the person and the street property, this will allow us to directly modify the street using this newly created lens.</p><p>Oh, by the way, we can also extend the original structs to provide these lenses by default. üëç</p><pre><code class="language-swift">extension Address {
    struct Lenses {
        static var street: Lens<Address, String> {
            .init(get: { $0.street },
                  set: { Address(street: $0, city: $1.city) })
        }
    }
}

extension Company {

    struct Lenses {
        static var address: Lens<Company, Address> {
            .init(get: { $0.address },
                  set: { Company(name: $1.name, address: $0) })
        }
    }
}

extension Person {

    struct Lenses {
        static var company: Lens<Person, Company> {
            .init(get: { $0.company },
                  set: { Person(name: $1.name, company: $0) })
        }
        
        static var companyAddressStreet: Lens<Person, String> {
            Person.Lenses.company
                .transition(Company.Lenses.address)
                .transition(Address.Lenses.street)
        }
    }

}

let oneInfiniteLoop = Address(street: "One Infinite Loop", city: "Cupertino")
let appleInc = Company(name: "Apple Inc.", address: oneInfiniteLoop)
let steveJobs = Person(name: "Steve Jobs", company: appleInc)

let newPerson = Person.Lenses.companyAddressStreet.set("Apple Park Way", steveJobs)

print(newPerson)
</code></pre><p>On the call site we were able to use one single line to update the street property of an immutable structure, of course we‚Äôre creating a new copy of the entire object, but that‚Äôs good since we wanted to avoid mutations. Of course we have to create quite a lot of lenses to make this magic happen under the hood, but sometimes it is worth the effort. ‚ò∫Ô∏è</p><h2>Prisms</h2><p>Now that we know how to set properties of a struct hierarchy using a lens, let me show you one more data type that we can use to alter enum values. Prisms are just like lenses, but they work with <a href="https://mislavjavor.github.io/2017-04-19/Swift-enums-are-sum-types.-That-makes-them-very-interesting/" target="_blank">sum types</a>. Long story short, enums are sum types, structs are product types, and the main difference is how many unique values can you represent with them.</p><pre><code class="language-swift">// 512 possible values (= 2 * 256)
struct ProductExample {
    let a: Bool // 2 possible values
    let b: Int8 // 256 possible values
}


// 258 possible values (= 2 + 256)
enum SumExample {
    case a(Bool) // 2 possible values
    case b(Int8) // 256 possible values
}
</code></pre><p>Another difference is that a prism getter can return a nil value and the setter can ‚Äúfail‚Äù, this means if it is not possible to set the value of the property it‚Äôll return the original data value instead.</p><pre><code class="language-swift">struct Prism<Whole, Part> {
    let tryGet: (Whole) -> Part?
    let inject: (Part) -> Whole
}
</code></pre><p>This is how we can implement a prism, we call the getter tryGet, since it returns an optional value, the setter is called inject because we try to inject a new partial value and return the whole if possible. Let me show you an example so it‚Äôll make more sense.</p><pre><code class="language-swift">enum State {
    case loading
    case ready(String)
}

extension State {

    enum Prisms {
        static var loading: Prism<State, Void> {
            .init(tryGet: {
                guard case .loading = $0 else {
                    return nil
                }
                return ()
            },
            inject: { .loading })
        }
        
        static var ready: Prism<State, String> {
            .init(tryGet: {
                guard case let .ready(message) = $0 else {
                    return nil
                }
                return message
            },
            inject: { .ready($0) })
        }
    }
}
</code></pre><p>we‚Äôve created a simple State enum, plus we‚Äôve extended it and added a new Prism namespace as an enum with two static properties. ExactlyOne static prism for every case that we have in the original State enum. We can use these prisms to check if a given state has the right value or construct a new state using the inject method.</p><pre><code class="language-swift">// create enums cases the regular way
let loadingState = State.loading
let readyState = State.ready("I'm ready.")

// this creates a new loading state using the prism
let newLoadingState = State.Prisms.loading.inject(())
// this creates a new ready state with a given value
let newReadyState = State.Prisms.ready.inject("Hurray!")


// trying to access the ready message through the prism
let nilMessage = State.Prisms.ready.tryGet(loadingState)
print(nilMessage)

// returns the message if the state has a ready value
let message = State.Prisms.ready.tryGet(readyState)
print(message)
</code></pre><p>The syntax seems like a bit strange at the first sight, but trust me Prisms can be very useful. You can also apply transformations on prisms, but that‚Äôs a more advanced topic for another day.</p><p>Anyway, this time I‚Äôd like to stop here, since optics are quite a huge topic and I simply can‚Äôt cover everything in one article. Hopefully this little article will help you to understand lenses and prisms just a bit better using the Swift programming language. üôÇ</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
