<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Styling by subclassing - </title>
    <meta name="description" content="Learn how to design and build reusable user interface elements by using custom view subclasses from the UIKit framework in Swift.">
    
    <meta property="og:url" content="/posts/styling-by-subclassing/">
    <meta property="og:title" content="Styling by subclassing - ">
    <meta property="og:description" content="Learn how to design and build reusable user interface elements by using custom view subclasses from the UIKit framework in Swift.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Styling by subclassing - ">
    <meta name="twitter:description" content="Learn how to design and build reusable user interface elements by using custom view subclasses from the UIKit framework in Swift.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/about/">About</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2019-02-19 16:20:00">2019-02-19 16:20:00</time>
            <h1 class="title">Styling by subclassing</h1>
            <p class="excerpt">Learn how to design and build reusable user interface elements by using custom view subclasses from the UIKit framework in Swift.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>The problem: UI, UX, design</h2><blockquote><p>Building user interfaces is the hardest part of the job!</p></blockquote><p>In a nutshell: design is a process of figuring out the best solution that fits a specific problem. Graphic design usually means the physical drawing on a canvas or a paper. UX is literally how the user interacts with the application, in other words: the overall virtual experience of the ‚Äúcustomer‚Äù journey. UI is the visible interface that he/she will see and interact with by touching the screen. üëÜ</p><p>If I have to put on the designer hat (or even the developer hat) I have to tell you that figuring out and implementing proper user interfaces is the most challenging problem in most of the cases. Frontend systems nowadays (mobile, tablet, even desktop apps) are just fancy overlays on top of some JSON data from a service / API. ü§∑‚Äç‚ôÇÔ∏è</p><p>Why is it so hard? Well, I believe that if you want to be a good designer, you need a proper engineering mindset as well. You have to be capable of observing the whole system (big picture), construct consistent UI elements (that actually look the same everywhere), plan the desired experience based on the functional specification and many more. It‚Äôs also quite a basic requirement to be an artist, think outside of the box, and be able to explain (describe) your idea to others. ü§Ø</p><p>Now tell me whose job is the hardest in the tech industry? Yep, as a gratis everyone is a designer nowadays, also some companies don‚Äôt hire this kind of experts at all, but simply let the work done by the developers. Anyway, let‚Äôs focus on how to create nice and reusable design implementations by using subclasses in Swift. üëç</p><h2>Appearance, themes and styles</h2><p>Let me start with a confession: I barely use the <a href="https://nshipster.com/uiappearance/" target="_blank">UIAppearance</a> API. This is a personal preference, but I like to set design properties like font, textColor, backgroundColor directly on the view instances. Although in some cases I found the appearance proxy very nice, but still a little buggy. Maybe this will change with iOS 13 and the arrival of the long awaited <a href="https://medium.com/@mczachurski/ios-dark-theme-9a12724c112d" target="_blank">dark mode</a>.</p><blockquote><p>Dear Apple please make an auto switch based on day / night cycles (you know like the sunset, sunrise option in the home app). üåô</p></blockquote><ul><li>Style is a collection of attributes that specify the appearance for a single view.</li><li>Theme is a set of similar looking view styles, applied to the whole application.</li></ul><p>Nowadays I usually create some predefined set of styling elements, most likely fonts, colors, but sometimes icons, etc. I like to go with the following structure:</p><p>Fonts</p><ul><li>title</li><li>heading</li><li>subheading</li><li>body</li><li>small</li></ul><p>Colors</p><ul><li>title</li><li>heading</li><li>background</li></ul><p>Icons</p><ul><li>back</li><li>share</li></ul><p>You can have even more elements, but for the sake of simplicity let‚Äôs just implement these ones with a really simple Swift solution using nested structs:</p><pre><code class="language-swift">struct App {

    struct Fonts {
        static let title = UIFont.systemFont(ofSize: 32)
        static let heading = UIFont.systemFont(ofSize: 24)
        static let subheading = UIFont.systemFont(ofSize: 20)
        static let body = UIFont.systemFont(ofSize: 16)
        static let small = UIFont.systemFont(ofSize: 14)
    }

    struct Colors {
        static let title = UIColor.blue
        static let heading = UIColor.black
        static let background = UIColor.white
    }

    struct Icons {
        static let back = UIImage(named: "BackIcon")!
        static let share = UIImage(named: "ShareIcon")!
    }

}

//usage example:
App.Fonts.title
App.Colors.background
App.Icons.back
</code></pre><p>This way I get a pretty simple syntax, which is nice, although this won‚Äôt let me do dynamic styling, so I can not switch between light / dark <a href="https://medium.com/@martinho_t/how-i-use-uiappearance-to-manage-my-app-theme-part-1-2-1c4313e90b3a" target="_blank">theme</a>, but I really don‚Äôt mind that, because in most of the cases it‚Äôs not a requirement. üòÖ</p><h2>Structs vs enums:</h2><p>I could use enums instead of structs with static properties, but in this case I like the simplicity of this approach. I don‚Äôt want to mess around with raw values or extensions that accepts enums. It‚Äôs just a personal preference.</p><p>What if you have to support <a href="http://basememara.com/protocol-oriented-themes-for-ios-apps/" target="_blank">multiple themes</a>?</p><p>That‚Äôs not a big issue, you can define a protocol for your needs, and implement the required theme protocol as you want. The real problem is when you have to switch between your themes, because you have to refresh / reload your entire UI. ‚ôªÔ∏è</p><p>There are some best practices, for example you can use the NSNotificationCenter class in order to notify every view / controller in your app to refresh if a theme change occurs. Another solution is to simply <a href="https://theswiftdev.com/2017/10/10/swift-4-init-patterns/" target="_blank">reinitialize</a> the whole UI of the application, so this means you basically start from scratch with a brand new rootViewController. üò±</p><p>Anyway, check the links below if you need something like this, but if you just want to support dark mode in your app, I‚Äôd suggest to wait until the first iOS 13 beta comes out. Maybe Apple will give some shiny new API to make things easy.</p><h2>Custom views as style elements</h2><p>I promised <a href="https://felginep.github.io/2019-02-19/uiview-styling-with-functions" target="_blank">styling</a> by subclassing, so let‚Äôs dive into the topic. Now that we have a good solution to define fonts, colors and other basic building blocks, it‚Äôs time to apply those styles to actual UI elements. Of course you can use the <a href="https://www.raywenderlich.com/652-uiappearance-tutorial-getting-started" target="_blank">UIAppearance</a> API, but for example you can‚Äôt simply set custom <a href="https://pspdfkit.com/blog/2018/improving-dynamic-type-support/" target="_blank">fonts</a> through the appearance proxy. üò¢</p><p>Another thing is that I love consistency in design. So if a title is a blue, 32pt bold system font somewhere in my application I also expect that element to follow the same guideline everywhere else. I solve this problem by creating subclasses for every single view element that has a custom style applied to it. So for example:</p><ul><li>TitleLabel (blue color, 32pt system font)</li><li>HeadingLabel (blue color, 24pt system font)</li><li>StandardButton (blue background)</li><li>DestructiveButton (red background)</li></ul><p>Another good thing if you have subclasses and you‚Äôre working with autolayout constraints from code, that you can put all your constraint creation logic directly into the subclass itself. Let me show you an example:</p><pre><code class="language-swift">import UIKit

class TitleLabel: UILabel {

    override init(frame: CGRect) {
        super.init(frame: frame)

        self.initialize()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)

        self.initialize()
    }

    init() {
        super.init(frame: .zero)

        self.initialize()
    }

    func initialize() {
        self.translatesAutoresizingMaskIntoConstraints = false
        self.textColor = App.Colors.title
        self.font = App.Fonts.title
    }

    func constraints(in view: UIView) -> [NSLayoutConstraint] {
        return [
            self.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 16),
            self.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: -16),
            self.centerYAnchor.constraint(equalTo: view.centerYAnchor),
        ]
    }
}
</code></pre><p>As you can see I only have to set the font & textColor attributes once, so after the <a href="https://theswiftdev.com/2017/10/11/uikit-init-patterns/" target="_blank">view initialization</a> is done, I can be sure that every single instance of TitleLabel will look exactly the same. The usage is pretty simple too, you just have to set the class name in interface builder, or you can simply create the view like this:</p><pre><code class="language-swift">// loadView method in a view controller...
let titleLabel = TitleLabel()
self.view.addSubview(titleLabel)
NSLayoutConstraint.activate(titleLabel.constraints(in: self.view))
</code></pre><p>The thing I like the most about this approach is that my constraints are going to be just in the right place, so they won‚Äôt bloat my view controller‚Äôs loadView method. You can also create multiple constraint variations based on your current situation with extra parameters, so it‚Äôs quite scalable for every situation. üëç</p><h2>View initialization is hard</h2><p>The downside of this solution is that view initialization is kind of messed up, because of the interface builder support. You have to subclass every single view type (button, label, etc) and literally copy & paste your initialization methods again and again. I already have some articles about this, check the links below. üëá</p><p>In order to solve this problem I usually end up by creating a parent class for my own styled views. Here is an example for an abstract base class for my labels:</p><pre><code class="language-swift">class Label: UILabel {

    override init(frame: CGRect) {
        super.init(frame: frame)

        self.initialize()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)

        self.initialize()
    }

    init() {
        super.init(frame: .zero)

        self.initialize()
    }

    func initialize() {
        self.translatesAutoresizingMaskIntoConstraints = false
    }
}
</code></pre><p>So from now on I just have to override the initialize method.</p><pre><code class="language-swift">class TitleLabel: Label {

    override func initialize() {
        super.initialize()

        self.font = App.Fonts.title
        self.textColor = App.Colors.title
    }
}
</code></pre><p>See, it‚Äôs so much better, because I don‚Äôt have to deal with the required view initialization methods anymore, also auto-resizing will be off by default. ‚ù§Ô∏è</p><p>My final takeaway from this lesson is that you should not be afraid of classes and object oriented programming if it comes to the UIKit framework. Protocol oriented programming (also functional programming) is great if you use it in the right place, but since UIKit is quite an OOP framework I believe it‚Äôs still better to follow these paradigms instead of choosing some hacky way. ü§™</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
