<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Hummingbird routing and requests - </title>
    <meta name="description" content="Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.">
    
    <meta property="og:url" content="/posts/hummingbird-routing-and-requests/">
    <meta property="og:title" content="Hummingbird routing and requests - ">
    <meta property="og:description" content="Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Hummingbird routing and requests - ">
    <meta name="twitter:description" content="Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/about/">About</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
            <h1 class="title">Hummingbird routing and requests</h1>
            <p class="excerpt">Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <p>Routing on the server side means the server is going to send a response based on the URL path that the client called when firing up the HTTP request. Of course the server can check additional parameters and headers to build the final response, but when we talk about routing in general, we usually refer to the path components. <a href="https://hummingbird-project.github.io/hummingbird-docs/documentation/hummingbird/router/" target="_blank">Hummingbird</a> uses a <a href="https://en.wikipedia.org/wiki/Trie" target="_blank">trie-based</a> router, which is a fast and efficient way of looking up routes. It‚Äôs quite simple to respond to HTTP request using the built-in router, you can simply add your basic route handlers like this:</p><pre><code class="language-swift">/// on path X, when method is Y, call the handler... 
router.on("foo", method: .HEAD) { _ -> HTTPResponseStatus in .ok }
router.on("foo", method: .GET) { _ -> HTTPResponseStatus in .ok }
router.on("foo", method: .POST) { _ -> HTTPResponseStatus in .ok }
router.on("foo", method: .PUT) { _ -> HTTPResponseStatus in .ok }
router.on("foo", method: .PATCH) { _ -> HTTPResponseStatus in .ok }
router.on("foo", method: .DELETE) { _ -> HTTPResponseStatus in .ok }

/// short version (for some HTTP methods)
router.head("foo") { _ -> HTTPResponseStatus in .ok }
router.get("foo") { _ -> HTTPResponseStatus in .ok }
router.put("foo") { _ -> HTTPResponseStatus in .ok }
router.post("foo") { _ -> HTTPResponseStatus in .ok }
router.patch("foo") { _ -> HTTPResponseStatus in .ok }
router.delete("foo") { _ -> HTTPResponseStatus in .ok }
</code></pre><p>In Hummingbird it is also possible to register use a function instead of a block. Handler functions can be async and throwing too, so you can mark the blocks with these keywords or use asynchronous Swift functions when registering route handlers. If you don‚Äôt provide the first parameter, the path as a string, the route handler is going to be attached to the base group. üëç</p><p>You can also prefix a path component with a colon, this will turn that component into a dynamic route parameter. The parameter is going to be named after the path component, by simply dropping the colon prefix. You can access parameters inside your route handler through the req.parameters property. It is also possible to register multiple components using a / character.</p><pre><code class="language-swift">public extension HBApplication {
    
    func configure() throws {

        router.get { _ async throws in "Hello, world!" }

        router.get("hello/:name") { req throws in
            guard let name = req.parameters.get("name") else {
                throw HBHTTPError(
                    .badRequest,
                    message: "Invalid name parameter."
                )
            }
            return "Hello, \(name)!"
        }

        let group = router.group("todos")
        group.get(use: list)
        group.post(use: create)
        
        let idGroup = group.group(":todoId")
        idGroup.head(use: check)
        idGroup.get(use: fetch)
        idGroup.put(use: update)
        idGroup.patch(use: patch)
        idGroup.delete(use: delete)

        /// short version
        router.group("todos")
            .get(use: list)
            .post(use: create)
            .group(":todoId")
                .head(use: check)
                .get(use: fetch)
                .put(use: update)
                .patch(use: patch)
                .delete(use: delete)

    }

    func list(_ req: HBRequest) async throws -> HTTPResponseStatus { .ok }
    func check(_ req: HBRequest) async throws -> HTTPResponseStatus { .ok }
    func fetch(_ req: HBRequest) async throws -> HTTPResponseStatus { .ok }
    func create(_ req: HBRequest) async throws -> HTTPResponseStatus { .ok }
    func update(_ req: HBRequest) async throws -> HTTPResponseStatus { .ok }
    func patch(_ req: HBRequest) async throws -> HTTPResponseStatus { .ok }
    func delete(_ req: HBRequest) async throws -> HTTPResponseStatus { .ok }
}
</code></pre><p>It is possible to use a wildcard character (*) when detecting path components and the recursive version (**) to catch everything. Also you can use the ${name} syntax to catch a named request parameter even with a prefix or suffix, but you can‚Äôt insert this in the middle of a path component. (e.g. ‚Äúprefix-${name}.jpg‚Äù won‚Äôt work, but ‚Äú${name}.jpg‚Äù is just fine) üí°</p><pre><code class="language-swift">import Hummingbird
import HummingbirdFoundation

extension HBApplication {

    func configure(_ args: AppArguments) throws {

        router.get("foo-${name}", use: catchPrefix)
        router.get("${name}.jpg", use: catchSuffix)
        
        router.get("*", use: catchOne)
        router.get("*/*", use: catchTwo)

        router.get("**", use: catchAll)
        
    }
    
    // http://localhost:8080/bar
    func catchOne(_ req: HBRequest) async throws -> String {
        "one"
    }

    // http://localhost:8080/bar/baz/
    func catchTwo(_ req: HBRequest) async throws -> String {
        "two"
    }
    
    // http://localhost:8080/bar/baz/foo/bar/baz
    func catchAll(_ req: HBRequest) async throws -> String {
        "all: " + req.parameters.getCatchAll().joined(separator: ", ")
    }
    
    // http://localhost:8080/foo-bar
    func catchPrefix(_ req: HBRequest) async throws -> String {
        "prefix: " + (req.parameters.get("name") ?? "n/a")
    }
    
    // http://localhost:8080/bar.jpg
    func catchSuffix(_ req: HBRequest) async throws -> String {
        "suffix: " + (req.parameters.get("name") ?? "n/a")
    }
}
</code></pre><p>It is also possible to <a href="https://hummingbird-project.github.io/hummingbird-docs/documentation/hummingbird/router/#Editing-response-in-handler" target="_blank">edit the auto-generated response</a> if you specify the .editResponse option.</p><pre><code class="language-swift">router.get("foo", options: .editResponse) { req -> String in
    req.response.status = .ok
    req.response.headers.replaceOrAdd(
        name: "Content-Type", 
        value: "application/json"
    )
    return #"{"foo": "bar"}"#
}
</code></pre><p>Hummingbird support for body streaming is amazing, you can stream a HTTP request body by using the .streamBody option. The body stream has a sequence property, which you can use to iterate through the incoming <a href="https://swiftinit.org/reference/swift-nio/niocore/bytebuffer" target="_blank">ByteBuffer</a> chunks when handling the request. üîÑ</p><pre><code class="language-swift">func configure() throws { 
    router.post("foo", options: .streamBody) { req async throws -> String in
        guard
            let rawLength = req.headers["Content-Length"].first,
            let length = Int(rawLength),
            let stream = req.body.stream
        else {
            throw HBHTTPError(
                .badRequest,
                message: "Missing or invalid body stream."
            )
        }
        var count: Int = 0
        for try await chunk in stream.sequence {
            count += chunk.readableBytes
        }
        return String("\(length) / \(count)")
    }
}

// main.swift
let app = HBApplication(
    configuration: .init(
        address: .hostname(hostname, port: port),
        serverName: "Hummingbird",
        maxUploadSize: 1 * 1024 * 1024 * 1024 // 1GB
    )
)
</code></pre><p>As you can see you can easily access all the incoming headers via the req.headers container, you should note that this method will return header values in a case-insensitive way. If you want to stream larger files, you also have to set a custom maxUploadSize using the configuration object when initializing the HBApplication instance.</p><pre><code class="language-sh">curl -X POST http://localhost:8080/foo \
    -H "Content-Length: 3" \
    --data-raw 'foo'

curl -X POST http://localhost:8080/foo \
    -H "content-Length: 5242880" \
    -T ~/test
</code></pre><p>You can try out streaming with a simple cURL script, feel free to experiment with these.</p><p>Another thing I‚Äôd like to show you is how to access query parameters and other properties using the request object. Here is an all-in-one example, which you can use as a cheatsheet‚Ä¶ üòâ</p><pre><code class="language-swift">// curl -X GET http://localhost:8080/bar?q=foo&key=42
router.get("bar") { req async throws -> String in
            
    struct Foo: Codable {
        var a: String
    }

    print(req.method)
    print(req.headers)
    print(req.headers["accept"])
    print(req.uri.queryParameters.get("q") ?? "n/a")
    print(req.uri.queryParameters.get("key", as: Int.self) ?? 0)

    if let buffer = req.body.buffer {
        let foo = try? JSONDecoder().decode(Foo.self, from: buffer)
        print(foo ?? "n/a")
    }
    return "Hello, world!"
}
</code></pre><p>Anyway, there is one additional super cool feature in Hummingbird that I‚Äôd like to show you. It is possible to define a route handler, this way you can encapsulate everything into a single object. There is an async version of the <a href="https://hummingbird-project.github.io/hummingbird-docs/documentation/hummingbird/router/#Route-handlers" target="_blank">route handler protocol</a>, if you don‚Äôt need async, you can simply drop the keyword both from the protocol name & the method. I love this approach a lot. üòç</p><pre><code class="language-swift">struct MyRouteHandler: HBAsyncRouteHandler {

    struct Input: Decodable {
        let foo: String
    }

    struct Output: HBResponseEncodable {
        let id: String
        let foo: String
    }
    
    let input: Input

    init(from request: HBRequest) throws {
        self.input = try request.decode(as: Input.self)
    }

    func handle(request: HBRequest) async throws -> Output {
        .init(
            id: "id-1",
            foo: input.foo
        )
    }
}
</code></pre><p>The request.decode method uses the built-in decoder, which you have to explicitly set for the application, since we‚Äôre going to communicate using JSON data, we can use the JSON encoder / decoder from Foundation to automatically transform the data.</p><p>In order to make use of the custom route handler, you can simply register the object type.</p><pre><code class="language-swift">import Hummingbird
import HummingbirdFoundation

public extension HBApplication {

    func configure() throws {
        
        encoder = JSONEncoder()
        decoder = JSONDecoder()
                
        //    curl -i -X POST http://localhost:8080/foo \
        //        -H "Content-Type: application/json" \
        //        -H "Accept: application/json" \
        //        --data-raw '{"foo": "bar"}'
        router.post("foo", use: MyRouteHandler.self)
    }
}
</code></pre><p>You can read more about how the <a href="https://hummingbird-project.github.io/hummingbird-docs/documentation/hummingbird/encoding-and-decoding/" target="_blank">encoding and decoding</a> works in Hummingbird, but maybe that topic deserves its own blog post. If you have questions or suggestions, feel free to contact me. üôà</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
