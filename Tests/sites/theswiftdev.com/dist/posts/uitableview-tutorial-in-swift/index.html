<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>UITableView tutorial in Swift - </title>
    <meta name="description" content="This guide is made for beginners to learn the foundations of the UITableView class programmatically with auto layout in Swift.">
    
    <meta property="og:url" content="/posts/uitableview-tutorial-in-swift/">
    <meta property="og:title" content="UITableView tutorial in Swift - ">
    <meta property="og:description" content="This guide is made for beginners to learn the foundations of the UITableView class programmatically with auto layout in Swift.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="UITableView tutorial in Swift - ">
    <meta name="twitter:description" content="This guide is made for beginners to learn the foundations of the UITableView class programmatically with auto layout in Swift.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/about/">About</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2018-12-01 16:20:00">2018-12-01 16:20:00</time>
            <h1 class="title">UITableView tutorial in Swift</h1>
            <p class="excerpt">This guide is made for beginners to learn the foundations of the UITableView class programmatically with auto layout in Swift.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>How to create a table view programmatically?</h2><p>Let‚Äôs jump straight into the <a href="http://www.thomashanning.com/uitableview-tutorial-for-beginners/" target="_blank">coding</a> part, but first: start Xcode, create a new iOS single view app project, enter some name & details for the project as usual, use Swift and finally open the ViewController.swift file right away. Now grab your keyboard! ‚å®Ô∏è</p><blockquote><p>Pro tip: use Cmd+Shift+O to quickly jump between files</p></blockquote><p>I‚Äôm not going to use interface builder in this tutorial, so how do we create views programmatically? There is a method called loadView that‚Äôs where you should add custom views to your view hierarchy. You can option+click the method name in Xcode & read the discussion about <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621454-loadview" target="_blank">loadView</a> method, but let me summarize the whole thing.</p><p>We‚Äôll use a weak property to hold a reference to our table view. Next, we override the loadView method & call super, in order to load the controller‚Äôs self.view property with a view object (from a nib or a storyboard file if there is one for the controller). After that we assign our brand new view to a local property, turn off system provided layout stuff, and insert our table view into our view hierarchy. Finally we create some real constraints using anchors & save our pointer to our weak property. Easy! ü§™</p><pre><code class="language-swift">class ViewController: UIViewController {

    weak var tableView: UITableView!

    override func loadView() {
        super.loadView()

        let tableView = UITableView(frame: .zero, style: .plain)
        tableView.translatesAutoresizingMaskIntoConstraints = false
        self.view.addSubview(tableView)
        NSLayoutConstraint.activate([
        self.view.safeAreaLayoutGuide.topAnchor.constraint(equalTo: tableView.topAnchor),
            self.view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: tableView.bottomAnchor),
            self.view.leadingAnchor.constraint(equalTo: tableView.leadingAnchor),
            self.view.trailingAnchor.constraint(equalTo: tableView.trailingAnchor),
        ])
        self.tableView = tableView
    }
}
</code></pre><p>Always use auto layout anchors to specify view constraints, if you don‚Äôt know how to use them, check my <a href="https://theswiftdev.com/2018/06/14/mastering-ios-auto-layout-anchors-programmatically-from-swift/" target="_blank">layout anchors tutorial</a>, it‚Äôs takes only about 15 minutes to learn this API, and you won‚Äôt regret it. It‚Äôs an extremely useful tool for any iOS developer! üòâ</p><p>You might ask: should I use <a href="https://krakendev.io/blog/weak-and-unowned-references-in-swift" target="_blank">weak or strong</a> properties for view references? I‚Äôd say in most of the cases if you are not overriding self.view you should use weak! The view hierarchy will hold your custom view through a strong reference, so there is no need for stupid retain cycles & memory leaks. Trust me! ü§•</p><h2>UITableViewDataSource basics</h2><p>Okay, we have an empty table view, let‚Äôs display some <a href="https://samwize.com/2016/02/24/everything-about-uitableview/" target="_blank">cells</a>! In order to fill our table view with real data, we have to conform to the UITableViewDataSource protocol. Through a simple <a href="https://theswiftdev.com/2018/06/27/swift-delegate-design-pattern/" target="_blank">delegate pattern</a>, we can provide various information for the UITableView class, so it‚Äôll to know how much sections and rows will be needed, what kind of cells should be displayed for each row, and many more little details.</p><p>Another thing is that UITableView is a really efficient class. It‚Äôll reuse all the cells that are currently not displayed on the screen, so it‚Äôll consume way less memory than a UIScrollView, if you have to deal with hundreds or thousands of items. To support this behavior we have to register our cell class with a reuse identifier, so the underlying system will know what kind of cell is needed for a specific place. ‚öôÔ∏è</p><pre><code class="language-swift">class ViewController: UIViewController {

    var items: [String] = [
        "üëΩ", "üê±", "üêî", "üê∂", "ü¶ä", "üêµ", "üêº", "üê∑", "üí©", "üê∞",
        "ü§ñ", "ü¶Ñ", "üêª", "üê≤", "ü¶Å", "üíÄ", "üê®", "üêØ", "üëª", "ü¶ñ",
    ]

    override func viewDidLoad() {
        super.viewDidLoad()

        self.tableView.register(UITableViewCell.self, forCellReuseIdentifier: "UITableViewCell")

        self.tableView.dataSource = self
    }
}

extension ViewController: UITableViewDataSource {

    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return self.items.count
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "UITableViewCell", for: indexPath)
        let item = self.items[indexPath.item]
        cell.textLabel?.text = item
        return cell
    }
}
</code></pre><p>After adding a few lines of code to our view controller file, the table view is now able to display a nice list of emojis! We are using the built-in UITableViewCell class from UIKit, which comes really handy if you are good to go with the ‚ÄúiOS-system-like‚Äù cell designs. We also conformed to the data source protocol, by telling how many items are in our section (currently there is only one section), and we configured our cell inside the famous cell for row at indexPath delegate method. üòé</p><h2>Customizing table view cells</h2><p>UITableViewCell can provide some basic elements to display data (title, detail, image in different styles), but usually you‚Äôll need custom designed cells. Here is a basic template of a custom cell subclass, I‚Äôll explain all the methods after the code.</p><pre><code class="language-swift">class MyCell: UITableViewCell {

    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)

        self.initialize()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)

        self.initialize()
    }

    func initialize() {

    }
    /*
    override func awakeFromNib() {
        super.awakeFromNib()

    }
    */
    override func prepareForReuse() {
        super.prepareForReuse()

    }
}
</code></pre><p>The <code>init(style:reuseIdentifier)</code> method is a great place to override the cell style property if you are going to use the default UITableViewCell programmatically, but with different styles (there is no option to set cellStyle after the cell was initialized). For example if you need a <code>.value1</code> styled cell, just pass the argument directly to the super call. This way you can benefit from the 4 predefined <a href="https://developer.apple.com/documentation/uikit/uitableviewcellstyle" target="_blank">cell styles</a>.</p><blockquote><p>You‚Äôll also have to implement <code>init(coder:)</code>, so you should create a common initialize() function where you‚Äôll be able to add your custom views to the view hierarchy, like we did in the loadView method above. If you are using xib files & IB, you can use the awakeFromNib method to add extra style to your views through the standard <code>@IBOutlet</code> properties (or add extra views to the hierarchy as well). üëç</p></blockquote><p>The last method that we have to talk about is <code>prepareForReuse</code>. As I mentioned before cells are being reused so if you want to reset some properties, like the background of a cell, you can do it here. This method will be called before the cell is going to be reused.</p><p>Let‚Äôs make two new cell subclasses to play around with.</p><pre><code class="language-swift">class DetailCell: UITableViewCell {

    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: .subtitle, reuseIdentifier: reuseIdentifier)

        self.initialize()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)

        self.initialize()
    }

    func initialize() {
        // nothing to do here :)
    }

    override func prepareForReuse() {
        super.prepareForReuse()

        self.textLabel?.text = nil
        self.detailTextLabel?.text = nil
        self.imageView?.image = nil
    }
}
</code></pre><p>Our custom cell will have a big image background plus a title label in the center of the view with a custom sized system font. Also I‚Äôve added the <a href="https://commons.wikimedia.org/wiki/File:Swift_logo.svg" target="_blank">Swift logo</a> as an asset to the project, so we can have a nice demo image. üñº</p><pre><code class="language-swift">class CustomCell: UITableViewCell {

    weak var coverView: UIImageView!
    weak var titleLabel: UILabel!

    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)

        self.initialize()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)

        self.initialize()
    }

    func initialize() {
        let coverView = UIImageView(frame: .zero)
        coverView.translatesAutoresizingMaskIntoConstraints = false
        self.contentView.addSubview(coverView)
        self.coverView = coverView

        let titleLabel = UILabel(frame: .zero)
        titleLabel.translatesAutoresizingMaskIntoConstraints = false
        self.contentView.addSubview(titleLabel)
        self.titleLabel = titleLabel

        NSLayoutConstraint.activate([
            self.contentView.topAnchor.constraint(equalTo: self.coverView.topAnchor),
            self.contentView.bottomAnchor.constraint(equalTo: self.coverView.bottomAnchor),
            self.contentView.leadingAnchor.constraint(equalTo: self.coverView.leadingAnchor),
            self.contentView.trailingAnchor.constraint(equalTo: self.coverView.trailingAnchor),

            self.contentView.centerXAnchor.constraint(equalTo: self.titleLabel.centerXAnchor),
            self.contentView.centerYAnchor.constraint(equalTo: self.titleLabel.centerYAnchor),
        ])

        self.titleLabel.font = UIFont.systemFont(ofSize: 64)
    }

    override func prepareForReuse() {
        super.prepareForReuse()

        self.coverView.image = nil
    }
}
</code></pre><p>That‚Äôs it, let‚Äôs start using these new cells. I‚Äôll even tell you how to set custom height for a given cell, and how to handle cell selection properly, but first we need to get to know with another delegate protocol. ü§ù</p><h2>Basic UITableViewDelegate tutorial</h2><p>This delegate is responsible for lots of things, but for now we‚Äôre going to cover just a few interesting aspects, like how to handle cell selection & provide a custom cell height for each items inside the table. Here is a quick sample code.</p><pre><code class="language-swift">class ViewController: UIViewController {

    override func viewDidLoad() {
            super.viewDidLoad()

            self.tableView.register(UITableViewCell.self, forCellReuseIdentifier: "UITableViewCell")
            self.tableView.register(DetailCell.self, forCellReuseIdentifier: "DetailCell")
            self.tableView.register(CustomCell.self, forCellReuseIdentifier: "CustomCell")

            self.tableView.dataSource = self
            self.tableView.delegate = self
    }
}
extension ViewController: UITableViewDataSource {

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "CustomCell", for: indexPath) as! CustomCell
        let item = self.items[indexPath.item]
        cell.titleLabel.text = item
        cell.coverView.image = UIImage(named: "Swift")
        return cell
    }
}

extension ViewController: UITableViewDelegate {

    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 128
    }

    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
        let item = self.items[indexPath.item]

        let alertController = UIAlertController(title: item, message: "is in da house!", preferredStyle: .alert)
        let action = UIAlertAction(title: "Ok", style: .default) { _ in }
        alertController.addAction(action)
        self.present(alertController, animated: true, completion: nil)
    }
}
</code></pre><p>As you can see I‚Äôm registering my brand new custom cell classes in the <code>viewDidLoad</code> method. I also changed the code inside the <code>cellForRowAt</code> indexPath method, so we can use the <code>CustomCell</code> class instead of <code>UITableViewCells</code>. Don‚Äôt be afraid of force casting here, if something goes wrong at this point, your app should crash. üôÉ</p><p>There are two delegate methods that we are using here. In the first one, we have to return a number and the system will use that height for the cells. If you want to use different cell height per row, you can achieve that too by checking indexPath property or anything like that. The second one is the handler for the selection. If someone taps on a cell, this method will be called & you can perform some action.</p><blockquote><p>An indexPath has two interesting properties: section & item (=row)</p></blockquote><h2>Multiple sections with headers and footers</h2><p>It‚Äôs possible to have <a href="https://medium.com/@stasost/ios-how-to-build-a-table-view-with-multiple-cell-types-2df91a206429" target="_blank">multiple</a> sections inside the table view, I won‚Äôt go too much into the details, because it‚Äôs pretty straightforward. You just have to use indexPaths in order to get / set / return the proper data for each section & cell.</p><pre><code class="language-swift">import UIKit

class ViewController: UIViewController {

    weak var tableView: UITableView!

    var placeholderView = UIView(frame: .zero)
    var isPullingDown = false

    enum Style {
        case `default`
        case subtitle
        case custom
    }

    var style = Style.default

    var items: [String: [String]] = [
        "Originals": ["üëΩ", "üê±", "üêî", "üê∂", "ü¶ä", "üêµ", "üêº", "üê∑", "üí©", "üê∞","ü§ñ", "ü¶Ñ"],
        "iOS 11.3": ["üêª", "üê≤", "ü¶Å", "üíÄ"],
        "iOS 12": ["üê®", "üêØ", "üëª", "ü¶ñ"],
    ]

    override func loadView() {
        super.loadView()

        let tableView = UITableView(frame: .zero, style: .plain)
        tableView.translatesAutoresizingMaskIntoConstraints = false
        self.view.addSubview(tableView)
        NSLayoutConstraint.activate([
            self.view.safeAreaLayoutGuide.topAnchor.constraint(equalTo: tableView.topAnchor),
            self.view.safeAreaLayoutGuide.bottomAnchor.constraint(equalTo: tableView.bottomAnchor),
            self.view.leadingAnchor.constraint(equalTo: tableView.leadingAnchor),
            self.view.trailingAnchor.constraint(equalTo: tableView.trailingAnchor),
        ])
        self.tableView = tableView
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        self.tableView.register(UITableViewCell.self, forCellReuseIdentifier: "UITableViewCell")
        self.tableView.register(DetailCell.self, forCellReuseIdentifier: "DetailCell")
        self.tableView.register(CustomCell.self, forCellReuseIdentifier: "CustomCell")

        self.tableView.dataSource = self
        self.tableView.delegate = self
        self.tableView.separatorStyle = .singleLine
        self.tableView.separatorColor = .lightGray
        self.tableView.separatorInset = .zero

        self.navigationItem.rightBarButtonItem = .init(barButtonSystemItem: .refresh, target: self, action: #selector(self.toggleCells))
    }

    @objc func toggleCells() {

        switch self.style {
        case .default:
            self.style = .subtitle
        case .subtitle:
            self.style = .custom
        case .custom:
            self.style = .default
        }

        DispatchQueue.main.async {
            self.tableView.reloadData()
        }
    }

    // MARK: - helpers

    func key(for section: Int) -> String {
        let keys = Array(self.items.keys).sorted { first, last -> Bool in
            if first == "Originals" {
                return true
            }
            return first < last
        }
        let key = keys[section]
        return key
    }

    func items(in section: Int) -> [String] {
        let key = self.key(for: section)
        return self.items[key]!
    }

    func item(at indexPath: IndexPath) -> String {
        let items = self.items(in: indexPath.section)
        return items[indexPath.item]
    }
}

extension ViewController: UITableViewDataSource {

    func numberOfSections(in tableView: UITableView) -> Int {
        return self.items.keys.count
    }

    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return self.items(in: section).count
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let item = self.item(at: indexPath)
        let cell = tableView.dequeueReusableCell(withIdentifier: "CustomCell", for: indexPath) as! CustomCell
        cell.titleLabel.text = item
        cell.coverView.image = UIImage(named: "Swift")
        return cell
    }

    func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
        return self.key(for: section)
    }

}

extension ViewController: UITableViewDelegate {

    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 128
    }

    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)

        let item = self.item(at: indexPath)
        let alertController = UIAlertController(title: item, message: "is in da house!", preferredStyle: .alert)
        let action = UIAlertAction(title: "Ok", style: .default) { _ in }
        alertController.addAction(action)
        self.present(alertController, animated: true, completion: nil)
    }
}
</code></pre><p>Although there is one interesting addition in the code snippet above. You can have a custom title for every section, you just have to add the <code>titleForHeaderInSection</code> data source method. Yep, it looks like shit, but this one is not about perfect UIs. üòÇ</p><p>However if you are not satisfied with the layout of the section titles, you can create a custom class & use that instead of the built-in ones. Here is how to do a custom section header view. Here is the implementation of the reusable view:</p><pre><code class="language-swift">class HeaderView: UITableViewHeaderFooterView {

    weak var titleLabel: UILabel!

    override init(reuseIdentifier: String?) {
        super.init(reuseIdentifier: reuseIdentifier)

        self.initialize()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)

        self.initialize()
    }

    func initialize() {
        let titleLabel = UILabel(frame: .zero)
        titleLabel.translatesAutoresizingMaskIntoConstraints = false
        self.contentView.addSubview(titleLabel)
        self.titleLabel = titleLabel

        NSLayoutConstraint.activate([
            self.contentView.centerXAnchor.constraint(equalTo: self.titleLabel.centerXAnchor),
            self.contentView.centerYAnchor.constraint(equalTo: self.titleLabel.centerYAnchor),
        ])

        self.contentView.backgroundColor = .black
        self.titleLabel.font = UIFont.boldSystemFont(ofSize: 16)
        self.titleLabel.textAlignment = .center
        self.titleLabel.textColor = .white
    }
}
</code></pre><p>There is only a few things left to do, you have to register your header view, just like you did it for the cells. It‚Äôs exactly the same way, except that there is a separate registration ‚Äúpool‚Äù for the header & footer views. Lastly you have to implement two additional, but relatively simple (and familiar) delegate methods.</p><pre><code class="language-swift">// This goes to viewDidLoad, but I don't want to embedd that much code... :)
// self.tableView.register(HeaderView.self, forHeaderFooterViewReuseIdentifier: "HeaderView")

extension ViewController: UITableViewDelegate {

    /* ... */

    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return 32
    }

    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let view = tableView.dequeueReusableHeaderFooterView(withIdentifier: "HeaderView") as! HeaderView
        view.titleLabel.text = self.key(for: section)
        return view
    }
}
</code></pre><blockquote><p>Footers works exactly the same as headers, you just have to implement the corresponding data source & delegate methods in order to support them.</p></blockquote><p>You can even have multiple cells in the same table view based on the row or section index or any specific business requirement. I‚Äôm not going to demo this here, because I have a way better solution for mixing and reusing cells inside the <a href="https://gitlab.com/corekit/CoreKit" target="_blank">CoreKit framework</a>. It‚Äôs already there for table views as well, plus I already covered this idea in my <a href="https://theswiftdev.com/2018/04/17/ultimate-uicollectionview-guide-with-ios-examples-written-in-swift/" target="_blank">ultimate collection view tutorial</a> post. You should check that too. ü§ì</p><h2>Section titles & indexes</h2><p>Ok, if your brain is not melted yet, I‚Äôll show you two more little things that can be interesting for beginners. The first one is based on two additional data source methods and it‚Äôs a very pleasant addition for long lists. (I prefer search bars!) ü§Ø</p><pre><code class="language-swift">extension ViewController: UITableViewDataSource {
    /* ... */

    func sectionIndexTitles(for tableView: UITableView) -> [String]? {
        return ["1", "2", "3"]
    }

    func tableView(_ tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int) -> Int {
        return index
    }
}
</code></pre><p>If you are going to implement these methods above you can have a little index view for your sections in the right side of the table view, so the end-user will be able to quickly jump between sections. Just like in the official contacts app. üìï</p><h2>Selection vs highlight</h2><p>Cells are highlighted when you are holding them down with your finger. Cell is going to be selected if you release your finger from the cell.</p><p>Don‚Äôt <a href="https://medium.com/@imho_ios/why-uitableviewcell-highlight-and-selection-styling-are-such-a-mystery-1ae1599e660a" target="_blank">over-complicate</a> this. You just have to implement two methods in you custom cell class to make everything work. I prefer to deselect my cells right away, if they‚Äôre not for example used by some sort of data picker layout. Here is the code:</p><pre><code class="language-swift">class CustomCell: UITableViewCell {

    /* ... */

    override func setSelected(_ selected: Bool, animated: Bool) {
        self.coverView.backgroundColor = selected ? .red : .clear
    }

    override func setHighlighted(_ highlighted: Bool, animated: Bool) {
        self.coverView.backgroundColor = highlighted ? .blue : .clear
    }
}
</code></pre><p>As you can see, it‚Äôs ridiculously easy, but most of the beginners don‚Äôt know how to do this. Also they usually forget to reset cells before the reusing logic happens, so the list keeps messing up cell states. Don‚Äôt worry too much about these problems, they‚Äôll go away as you‚Äôre going to be more experienced with the UITableView APIs.</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
