<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Practical guide to binary operations using the UInt8 type in Swift - </title>
    <meta name="description" content="Introduction to the basics of signed number representation and some practical binary operation examples in Swift using UInt8.">
    
    <meta property="og:url" content="/posts/practical-guide-to-binary-operations-using-the-uint8-type-in-swift/">
    <meta property="og:title" content="Practical guide to binary operations using the UInt8 type in Swift - ">
    <meta property="og:description" content="Introduction to the basics of signed number representation and some practical binary operation examples in Swift using UInt8.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Practical guide to binary operations using the UInt8 type in Swift - ">
    <meta name="twitter:description" content="Introduction to the basics of signed number representation and some practical binary operation examples in Swift using UInt8.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2021-09-16 16:20:00">2021-09-16 16:20:00</time>
            <h1 class="title">Practical guide to binary operations using the UInt8 type in Swift</h1>
            <p class="excerpt">Introduction to the basics of signed number representation and some practical binary operation examples in Swift using UInt8.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Integer types in Swift</h2><p>The Swift programming language has a bunch of different integer types. The Swift integer APIs were cleaned up by an old proposal named <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0104-improved-integers.md" target="_blank">Protocol-oriented Integers</a>, which resulted in a more generic way of expressing these kind of data types.</p><p><a href="https://andybargh.com/swift-numeric-data-types/" target="_blank">Numeric data types</a> in Swift are type safe by default, this makes a bit harder to perform operation using different integer (or floating point) types. Integers are divided into two main groups: signed and unsigned integers. In addition each members of these groups can be categorized by bit sizes. There are 8, 16, 32 & 64 bit long signed & unsigned integers plus generic integers. ü§î</p><p>Generic integers:</p><ul><li>Int (32 or 64 bit)</li><li>UInt (32 or 64 bit)</li></ul><p>Signed integers:</p><ul><li>Int8</li><li>Int16</li><li>Int32</li><li>Int64</li></ul><p>Unsigned integers:</p><ul><li>UInt8</li><li>UInt16</li><li>UInt32</li><li>UInt64</li></ul><p>You should know that the Int and UInt type size may vary on different platforms (32 vs 64 bits), but in order to be consistent, Apple recommends to always prefer the generic Int type over all the other variants. The Swift language always identifies all the integers using the Int type by default, so if you keep using this type you‚Äôll be able to perform integer operations without type conversions, your code will be easier to read and it‚Äôs going to be easier to move between platforms too. üí™</p><p>Most of the time you shouldn‚Äôt care about the length of the integer types, we can say that the generic Int and UInt types are quite often the best choices when you write Swift code. Except in those cases when your goal is to write extremely memory efficient or low level code‚Ä¶</p><h2>Representing numbers as integers</h2><p>Now that we know what kind of integers are available in Swift, it‚Äôs time to talk a bit about what kind of numbers can we represent using these data types.</p><pre><code class="language-swift">/// generic integers
print(Int.min)      //  -9223372036854775808
print(Int.max)      //   9223372036854775807
print(UInt.min)     //                     0
print(UInt.max)     //  18446744073709551615

/// unsigned integers
print(UInt8.min)    //                     0
print(UInt8.max)    //                   255
print(UInt16.min)   //                     0
print(UInt16.max)   //                 65535
print(UInt32.min)   //                     0
print(UInt32.max)   //            4294967295
print(UInt64.min)   //                     0
print(UInt64.max)   //  18446744073709551615

/// signed integers
print(Int8.min)     //                  -128
print(Int8.max)     //                   127
print(Int16.min)    //                -32768
print(Int16.max)    //                 32767
print(Int32.min)    //           -2147483648
print(Int32.max)    //            2147483647
print(Int64.min)    //  -9223372036854775808
print(Int64.max)    //   9223372036854775807
</code></pre><p>So there is a minimum and maximum value for each integer type that we can store in a given variable. For example, we can‚Äôt store the value 69420 inside a UInt8 type, because there are simply not enough <a href="https://en.wikipedia.org/wiki/Bit" target="_blank">bits</a> to represent this huge number. ü§ì</p><p>Let‚Äôs examine our 8 bit long unsigned integer type. 8 bit means that we have literally 8 places to store <a href="https://theswiftdev.com/all-about-the-bool-type-in-swift/" target="_blank">boolean</a> values (ones and zeros) using the <a href="https://en.wikipedia.org/wiki/Binary_number" target="_blank">binary number</a> representation. 0101 0110 in binary is 86 using the ‚Äúregular‚Äù decimal number format. This binary number is a base-2 numerical system (a positional notation) with a radix of 2. The number 86 can be interpreted as:</p><pre><code>0*28+1*27+0*26+1*25+0*24 + 1*23+1*22+0*21+0*20
0*128+1*64+0*32+1*16 + 0*8+1*4+1*2+0*1
64+16+4+2
86
</code></pre><p>We can convert back and forth between decimal and binary numbers, it‚Äôs not that hard at all, but let‚Äôs come back to this topic later on. In Swift we can check if a type is a signed type and we can also get the length of the integer type through the bitWidth property.</p><pre><code class="language-swift">print(Int.isSigned)     // true
print(UInt.isSigned)    // false
print(Int.bitWidth)     // 64
print(UInt8.bitWidth)   // 8
</code></pre><p>Based on this logic, now it‚Äôs quite straightforward that an 8 bit long unsigned type can only store 255 as the maximum value (1111 1111), since that‚Äôs 128+64+32+16+8+4+2+1.</p><p>What about signed types? Well, the trick is that 1 bit from the 8 is reserved for the positive / negative symbol. Usually the first bit represents the sign and the remaining 7 bits can store the actual numeric values. For example the Int8 type can store numbers from -128 til 127, since the maximum positive value is represented as 0111 1111, 64+32+16+8+4+2+1, where the leading zero indicates that we‚Äôre talking about a positive number and the remaining 7 bits are all ones.</p><p>So how the hack can we represent -128? Isn‚Äôt -127 (1111 1111) the minimum negative value? üòÖ</p><p>Nope, that‚Äôs not how negative binary numbers work. In order to understand negative integer representation using binary numbers, first we have to introduce a new term called <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">two‚Äôs complement</a>, which is a simple method of signed number representation.</p><h2>Basic signed number maths</h2><p>It is relatively easy to add two binary numbers, you just add the bits in order with a carry, just like you‚Äôd do addition using decimal numbers. Subtraction on the other hand is a bit harder, but fortunately it can be replaced with an addition operation if we store negative numbers in a special way and this is where two‚Äôs complement comes in.</p><p>Let‚Äôs imagine that we‚Äôd like to add two numbers:</p><ul><li>`0010 1010` (+42)</li><li>`0100 0101` +(+69)</li><li>`0110 1111` =(+111)</li></ul><p>Now let‚Äôs add a positive and a negative number stored using two‚Äôs complement, first we need to express -6 using a signed 8 bit binary number format:</p><ul><li>`0000 0110` (+6)</li><li>`1111 1001` (one‚Äôs complement = inverted bits)</li><li>`1111 1010` (two‚Äôs complement = add +1 (`0000 0001`) to one‚Äôs complement)</li></ul><p>Now we can simply perform an addition operation on the positive and negative numbers.</p><ul><li>`0010 1010` (+42)</li><li>`1111 1010` +(-6)</li><li>`(1) 0010 0100` =(+36)</li></ul><p>So, you might think, what‚Äôs the deal with the extra 1 in the beginning of the 8 bit result? Well, that‚Äôs called a carry bit, and in our case it won‚Äôt affect our final result, since we‚Äôve performed a subtraction instead of an addition. As you can see the remaining 8 bit represents the positive number 36 and 42-6 is exactly 36, we can simply ignore the extra flag for now. üòÖ</p><h2>Binary operators in Swift</h2><p>Enough from the theory, let‚Äôs dive in with some real world examples using the UInt8 type. First of all, we should talk <a href="https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html" target="_blank">about bitwise operators</a> in Swift. In my previous article we‚Äôve talked about <a href="https://theswiftdev.com/all-about-the-bool-type-in-swift/" target="_blank">Bool operators</a> (AND, OR, NOT) and the Boolean algebra, now we can say that those functions operate using a single bit. This time we‚Äôre going to see how bitwise operators can perform various transformations using multiple bits. In our sample cases it‚Äôs always going to be 8 bit. ü§ì</p><h3>Bitwise NOT operator</h3><p>This operator (<code>~</code>) inverts all bits in a number. We can use it to create one‚Äôs complement values.</p><pre><code class="language-swift">// one's complement
let x: UInt8 = 0b00000110    // 6 using binary format
let res = ~x                 // bitwise NOT
print(res)                   // 249, but why?
print(String(res, radix: 2)) // 1111 1001
</code></pre><p>Well, the problem is that we‚Äôll keep seeing decimal numbers all the time when using int types in Swift. We can print out the correct 1111 1001 result, using a String value with the base of 2, but for some reason the inverted number represents 249 according to our debug console. üôÉ</p><p>This is because the meaning of the UInt8 type has no understanding about the sign bit, and the 8th bit is always refers to the 28 value. Still, in some cases e.g. when you do low level programming, such as building a <a href="https://github.com/tib/SwiftNES" target="_blank">NES emulator written in Swift</a>, this is the right data type to choose.</p><p>The <a href="https://developer.apple.com/documentation/foundation/data" target="_blank">Data type</a> from the Foundation framework is considered to be a collection of UInt8 numbers. Actually you‚Äôll find quite a lot of use-cases for the UInt8 type if you take a deeper look at the existing frameworks & libraries. Cryptography, data transfers, etc.</p><p>Anyway, you can make an extension to easily print out the binary representation for any unsigned 8 bit number with leading zeros if needed. 0Ô∏è‚É£0Ô∏è‚É£0Ô∏è‚É£0Ô∏è‚É£ 0Ô∏è‚É£1Ô∏è‚É£1Ô∏è‚É£0Ô∏è‚É£</p><pre><code class="language-swift">/// UInt8+Binary.swift
import Foundation

fileprivate extension String {
    
    func leftPad(with character: Character, length: UInt) -> String {
        let maxLength = Int(length) - count
        guard maxLength > 0 else {
            return self
        }
        return String(repeating: String(character), count: maxLength) + self
    }
}

extension UInt8 {
    var bin: String {
        String(self, radix: 2).leftPad(with: "0", length: 8)
    }
}

let x: UInt8 = 0b00000110   // 6 using binary format
print(String(x, radix: 2))  // 110
print(x.bin)                // 00000110
print((~x).bin)             // 11111001 - one's complement
let res = (~x) + 1          // 11111010 - two's complement
print(res.bin)
</code></pre><p>We still have to provide our custom logic if we want to express signed numbers using UInt8, but that‚Äôs only going to happen after we know more about the other bitwise operators.</p><h3>Bitwise AND, OR, XOR operators</h3><p>These operators works just like you‚Äôd expect it from the truth tables. The AND operator returns a one if both the bits were true, the OR operator returns a 1 if either of the bits were true and the XOR operator only returns a true value if only one of the bits were true.</p><ul><li>AND `&` - 1 if both bits were 1</li><li>OR `|` - 1 if either of the bits were 1</li><li>XOR `^` - 1 if only one of the bits were 1</li><li></li></ul><p>Let me show you a quick example for each operator in Swift.</p><pre><code class="language-swift">let x: UInt8 = 42   // 00101010
let y: UInt8 = 28   // 00011100
// AND
print((x & y).bin)  // 00001000
// OR
print((x | y).bin)  // 00111110
// XOR
print((x ^ y).bin)  // 00110110
</code></pre><p>Mathematically speaking, there is not much reason to perform these operations, it won‚Äôt give you a sum of the numbers or other basic calculation results, but they have a different purpose.</p><p>You can use the bitwise AND operator to extract bits from a given number. For example if you want to store 8 (or less) individual true or false values using a single UInt8 type you can use a bitmask to extract & set given parts of the number. üò∑</p><pre><code class="language-swift">var statusFlags: UInt8 = 0b00000100

// check if the 3rd flag is one (value equals to 4)
print(statusFlags & 0b00000100 == 4)   // true

// check if the 5th flag is one (value equals to 16)
print(statusFlags & 0b00010000 == 16)  // false

// set the 5th flag to 1
statusFlags = statusFlags & 0b11101111 | 16
print(statusFlags.bin)  // 00010100

// set the 3rd flag to zero
statusFlags = statusFlags & 0b11111011 | 0
print(statusFlags.bin) // 00000100

// set the 5th flag back to zero
statusFlags = statusFlags & 0b11101111 | 0
print(statusFlags.bin) // 00000000

// set the 3rd flag back to one
statusFlags = statusFlags & 0b11101011 | 4
print(statusFlags.bin) // 00000100
</code></pre><p>This is nice, especially if you don‚Äôt want to mess around with 8 different Bool variables, but one there is one thing that is very inconvenient about this solution. We always have to use the right power of two, of course we could use <a href="https://developer.apple.com/documentation/foundation/1779833-pow" target="_blank">pow</a>, but there is a more elegant solution for this issue.</p><h3>Bitwise left & right shift operators</h3><p>By using a bitwise shift operation you can move a bit in a given number to left or right. Left shift is essentially a multiplication operation and right shift is identical with a division by a factor of two.</p><blockquote><p>‚ÄúShifting an integer‚Äôs bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value.‚Äù - <a href="https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html#ID34" target="_blank">swift.org</a></p></blockquote><p>It‚Äôs quite simple, but let me show you a few practical examples so you‚Äôll understand it in a bit. üòÖ</p><pre><code class="language-swift">let meaningOfLife: UInt8 = 42


// left shift 1 bit (42 * 2)
print(meaningOfLife << 1) // 84

// left shift 2 bits (42 * 2 * 2)
print(meaningOfLife << 2) // 168

// left shift 3 bits (42 * 2 * 2 * 2)
print(meaningOfLife << 3) // 80, it's an overflow !!!


// right shift 1 bit (42 / 2)
print(meaningOfLife >> 1) // 21

// right shift 2 bits (42 / 2 / 2)
print(meaningOfLife >> 2) // 10

// right shift 3 bits (42 / 2 / 2 / 2)
print(meaningOfLife >> 3) // 5

// right shift 4 bits (42 / 2 / 2 / 2 / 2)
print(meaningOfLife >> 4) // 2

// right shift 5 bits (42 / 2 / 2 / 2 / 2 / 2)
print(meaningOfLife >> 5) // 1

// right shift 6 bits (42 / 2 / 2 / 2 / 2 / 2 / 2)
print(meaningOfLife >> 6) // 0

// right shift 7 bits (42 / 2 / 2 / 2 / 2 / 2 / 2 / 2)
print(meaningOfLife >> 7) // 0
</code></pre><p>As you can see we have to be careful with left shift operations, since the result can overflow the 8 bit range. If this happens, the extra bit will just go away and the remaining bits are going to be used as a final result. Right shifting is always going to end up as a zero value. ‚ö†Ô∏è</p><p>Now back to our status flag example, we can use bit shifts, to make it more simple.</p><pre><code class="language-swift">var statusFlags: UInt8 = 0b00000100

// check if the 3rd flag is one
print(statusFlags & 1 << 2 == 1 << 2)

// set the 3rd flag to zero
statusFlags = statusFlags & ~(1 << 2) | 0
print(statusFlags.bin)

// set back the 3rd flag to one
statusFlags = statusFlags & ~(1 << 2) | 1 << 2
print(statusFlags.bin)
</code></pre><p>As you can see we‚Äôve used quite a lot of bitwise operations here. For the first check we use left shift to create our mask, bitwise and to extract the value using the mask and finally left shift again to compare it with the underlying value. Inside the second set operation we use left shift to create a mask then we use the not operator to invert the bits, since we‚Äôre going to set the value using a bitwise or function. I suppose you can figure out the last line based on this info, but if not just practice these operators, they are very nice to use once you know all the little the details. ‚ò∫Ô∏è</p><p>I think I‚Äôm going to cut it here, and I‚Äôll make just another post about overflows, carry bits and various transformations, maybe we‚Äôll involve hex numbers as well, anyway don‚Äôt want to promise anything specific. Bitwise operations are usueful and fun, just practice & don‚Äôt be afraid of a bit of math. üëæ</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
