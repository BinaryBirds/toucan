<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>The abstract Vapor service factory design pattern - </title>
    <meta name="description" content="In this tutorial I&#39;m going to show you how you can create an abstract driver-based component for the Vapor framework.">
    
    <meta property="og:url" content="/posts/the-abstract-vapor-service-factory-design-pattern/">
    <meta property="og:title" content="The abstract Vapor service factory design pattern - ">
    <meta property="og:description" content="In this tutorial I&#39;m going to show you how you can create an abstract driver-based component for the Vapor framework.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="The abstract Vapor service factory design pattern - ">
    <meta name="twitter:description" content="In this tutorial I&#39;m going to show you how you can create an abstract driver-based component for the Vapor framework.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/about/">About</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2023-02-01 16:20:00">2023-02-01 16:20:00</time>
            <h1 class="title">The abstract Vapor service factory design pattern</h1>
            <p class="excerpt">In this tutorial I&#39;m going to show you how you can create an abstract driver-based component for the Vapor framework.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <p>I‚Äôve written several articles about factory design patterns on my blog and this time I‚Äôd like to talk about a special one, which you can encounter if you work with Vapor. Here‚Äôs a little recap about my factory design pattern blog posts, all written in Swift:</p><ul><li>Swift factory method design pattern</li><li>Swift static factory design pattern</li><li>Swift simple factory design pattern</li><li>Swift abstract factory design pattern</li><li>Comparing factory design patterns</li></ul><p>Now let‚Äôs dive in to the ‚ÄúFluent pattern‚Äù. In order to understand this architecture, first we should examine the related Swift packages first. There is the <a href="https://github.com/vapor/fluent-kit" target="_blank">FluentKit</a> library and several Fluent database driver implementations (<a href="https://github.com/vapor/fluent-sqlite-driver" target="_blank">SQLite</a>, <a href="https://github.com/vapor/fluent-postgres-driver" target="_blank">PostgreSQL</a>, <a href="https://github.com/vapor/fluent-mysql-driver" target="_blank">MySQL</a>, etc.), all based on the FluentKit product. Also there is one package that connects Fluent with Vapor, this one is simply called: <a href="https://github.com/vapor/fluent" target="_blank">Fluent</a>. üìÄ</p><ul><li>FluentKit - contains the abstract interface (without Vapor, using SwiftNIO)</li><li>Fluent[xy]Driver - contains the implementation defined in FluentKit</li><li>Fluent - connects FluentKit with Vapor, by extending Vapor</li></ul><p>This is the base structure, the FluentKit library provides the following abstract interfaces, which you have to implement if you want to create your own driver implementation. Unfortunately you won‚Äôt be able to find proper documentation for these interfaces, so I‚Äôll explain them a bit:</p><ul><li>Database - Query execution and transaction related functions</li><li>DatabaseContext - Holds the config, logger, event loop, history and page size limit</li><li>DatabaseDriver - A factory interface to create and shutdown Database instances</li><li>DatabaseID - A unique ID to store database configs, drivers and instances</li><li>DatabaseError - A generic database related error protocol</li><li>DatabaseConfiguration - A protocol to create DatabaseDriver objects</li><li>DatabaseConfigurationFactory - A box-like object to hide driver related stuff</li><li>Databases - Shared config, driver and running instance storage</li></ul><p>As you can see there are many protocols involved in this architecture, but I‚Äôll try to walk you through the entire driver creation flow and hopefully you‚Äôll be able to understand how the pieces are related, and how can build your own drivers or even Vapor components based on this.</p><p>Fluent is written as a <a href="https://docs.vapor.codes/advanced/services/" target="_blank">service for Vapor</a> using the underlying shared storage object, this is what stores a reference to the <a href="https://github.com/vapor/fluent-kit/blob/main/Sources/FluentKit/Database/Databases.swift" target="_blank">Databases</a> instance. This object has two hash maps, for storing configurations and running driver instances using the DatabaseID as a key for both. üîë</p><p>When you ask for a driver, the Databases object will check if that driver exists, if yes, it‚Äôll simply return it and story over. The interesting part happens when the driver does not exists yet in the Databases storage. First the system will check for a pre-registered driver implementation.</p><pre><code class="language-swift">app.databases.use(.sqlite(.file("db.sqlite")), as: .sqlite)
</code></pre><p>This line above registers a new driver configuration for the shared Databases. The <code>.sqlite()</code> method is a static function on the <code>DatabaseConfigurationFactory</code> which creates a new SQLite specific configuration and hides it using the <code>init(make:)</code> call. The <a href="https://github.com/vapor/fluent-sqlite-driver/blob/main/Sources/FluentSQLiteDriver/FluentSQLiteConfiguration.swift" target="_blank">SQLite related configuration</a> implements the DatabaseConfiguration protocol, so it can be used as a valid config when the system creates the actual database context.</p><p>The config object is also responsible for creating the specific driver object using the Databases object if needed. At this point we‚Äôve got a configuration and a driver instance registered in the databases storage. What happens if someone asks for a database instance?</p><p>Depending on the context, you can ask for a Database implementation through the app.db or req.db properties. This is defined in the <a href="https://github.com/vapor/fluent/blob/main/Sources/Fluent/FluentProvider.swift" target="_blank">FluentProvider code</a> and behind the scenes everything can be traced back to the Databases class. Since you only want to have a single shared storage for all the drivers, but you also want to avoid the singleton pattern, you should hook this service up to the Application class. This is how the Vapor folks did it anyway. ü§ì</p><pre><code class="language-swift">let db: Database = req.db
let db: Database = req.db(.sqlite)

let db: Database = app.db
let db: Database = app.db(.sqlite)
</code></pre><p>When you ask for a database, or a database with an explicit identifier, you are essentially calling a make method inside the Databases class, which is going look for a registered configuration and a driver implementation using the hashes and it‚Äôll call the driver‚Äôs make method and pass around the logger, the event loop and the current database configuration as a database context object.</p><p>We can say that after you ask for an abstract <code>Database</code> driver, a new <code>DatabaseDriver</code> instance reference (associated with a given <code>DatabaseID</code>) will be stored inside the Databases class and it‚Äôll always make you a new Database reference with the current <code>DatabaseContext</code>. If the driver already exists, then it‚Äôll be reused, but you still get new Database references (with the associated context) every time. So, it is important to note that there is only one DatabaseDriver instance per configuration / database identifier, but it can create multiple Database objects. ü§î</p><p>Ok, I know, it‚Äôs quite complicated, but here‚Äôs an oversimplified version in Swift:</p><pre><code class="language-swift">final class Databases {
    var configs: [DatabaseID: DatabaseConfiguration] = [:]
    var drivers: [DatabaseID: DatabaseDriver] = [:]

    func make(
        _ id: DatabaseID,
        logger: Logger,
        on eventLoop: EventLoop
    ) -> Database {
        let config = configs[id]!

        if drivers[id] == nil {
            drivers[id] = config.make(self)
        }
        let context = DatabaseContext(config, logger, eventLoop)
        return drivers[id]!.make(context)
    }

    func use(_ config: DatabaseConfiguration, for id: DatabaseID) {
        configs[id] = config
    }
}
</code></pre><p>And the Vapor service extension could be interpreted somewhat like this:</p><pre><code class="language-swift">extension Application {

    var databases: Databases {
        get {
            if storage[DatabasesKey.self] == nil {
                storage[DatabasesKey.self] = .init()
            }
            return storage[DatabasesKey.self]
        }
        set {
            self.storage[MyConfigurationKey.self] = newValue
        }
    }

    var db: Database {
        databases.make(
            .default, 
            logger: logger, 
            eventLoop: eventLoopGroup.next()
        )
    }
}
</code></pre><p>You can apply the same principles and create an extension over the Request object to access a Database instance. Of course there‚Äôs a lot more happening under the hood, but the purpose of this article is to get a basic overview of this pattern, so I‚Äôm not going into those details now. üôÉ</p><p>Honestly I really like this approach, because it‚Äôs elegant and it can completely hide driver specific details through these abstractions. I followed the exact same principles when I created the <a href="https://github.com/binarybirds/liquid/" target="_blank">Liquid file storage driver for Vapor</a> and learned a lot during the process. Although, you should note that not everything is a good candidate for being implemented an ‚Äúabstract Vapor service factory‚Äù design pattern (or whatever we call this approach). Anyway, I really hope that this quick tutorial will help you to create your own Vapor components, if needed. ü§∑‚Äç‚ôÇÔ∏è</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
