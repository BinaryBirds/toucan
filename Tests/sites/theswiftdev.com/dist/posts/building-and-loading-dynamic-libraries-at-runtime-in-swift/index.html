<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Building and loading dynamic libraries at runtime in Swift - </title>
    <meta name="description" content="Learn how to create a plugin system using dynamic libraries and the power of Swift, aka. modular frameworks on the server-side.">
    
    <meta property="og:url" content="/posts/building-and-loading-dynamic-libraries-at-runtime-in-swift/">
    <meta property="og:title" content="Building and loading dynamic libraries at runtime in Swift - ">
    <meta property="og:description" content="Learn how to create a plugin system using dynamic libraries and the power of Swift, aka. modular frameworks on the server-side.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Building and loading dynamic libraries at runtime in Swift - ">
    <meta name="twitter:description" content="Learn how to create a plugin system using dynamic libraries and the power of Swift, aka. modular frameworks on the server-side.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2020-05-20 16:20:00">2020-05-20 16:20:00</time>
            <h1 class="title">Building and loading dynamic libraries at runtime in Swift</h1>
            <p class="excerpt">Learn how to create a plugin system using dynamic libraries and the power of Swift, aka. modular frameworks on the server-side.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Why should we make a plugin system?</h2><p>In the <a href="https://theswiftdev.com/modules-and-hooks-in-swift/" target="_blank">modules and hooks article</a> I was writing about how modules (plugins) can work together by using various invocation points and hooks. The only problem with that approach is that you can‚Äôt really turn on or off modules on-the-fly, since we usually build our apps in a static way.</p><p>A good plugin system should let us alter the behavior of our code at runtime. Wordpress plugins are extremely successful, because you can add extra functionality to the CMS without recompiling or altering the core. Outside the Apple ecosystem, there is a huge world that could take advantage of this concept. Yes, I am talking about Swift on the server and backend applications.</p><p>My idea here is to build an open-source modular CMS that can be fast, safe and extensible through plugins. Fortunately now we have this amazing type-safe programming language that we can use. Swift is fast and reliable, it is the perfect choice for building backend apps on the long term. ‚úÖ</p><p>In this article I would like to show you a how to build a dynamic plugin system. The whole concept is based on <a href="https://github.com/Lopdo" target="_blank">Lopdo</a>‚Äôs GitHub repositories, he did quite an amazing job implementing it. Thank you very much for showing me how to use <code>dlopen</code> and other similar functions. üôè</p><h2>The magic of dynamic linking</h2><p>Handmade <a href="https://theswiftdev.com/how-to-make-a-swift-framework/" target="_blank">iOS frameworks</a> are usually bundled with the application itself, you can learn pretty much <a href="https://theswiftdev.com/deep-dive-into-swift-frameworks/" target="_blank">everything about a framework</a> if you know some command line tools. This time we are only going to focus on static and dynamic linking. By default <a href="https://theswiftdev.com/the-swift-package-manifest-file/" target="_blank">Swift package dependencies</a> are linked statically into your application, but you can change this if you define a dynamic library product.</p><p>First we are going to create a shared plugin interface containing the plugin API as a protocol.</p><pre><code class="language-swift">// swift-tools-version:5.2
import PackageDescription

let package = Package(
    name: "PluginInterface",
    products: [
        .library(name: "PluginInterface", type: .dynamic, targets: ["PluginInterface"]),
    ],
    targets: [
        .target(name: "PluginInterface", dependencies: []),
    ]
)
</code></pre><p>This dynamic <code>PluginInterface</code> package can produce a <code>.dylib</code> or <code>.so</code> file, soon there will be a <code>.dll</code> version as well, based on the operating system. All the code bundled into this dynamic library can be shared between other applications. Let‚Äôs make a simple protocol.</p><pre><code class="language-swift">public protocol PluginInterface {

    func foo() -> String
}
</code></pre><p>Since we are going to load the plugin dynamically we will need something like a builder to construct the desired object. We can use a new abstract class for this purpose.</p><pre><code class="language-swift">open class PluginBuilder {
    
    public init() {}

    open func build() -> PluginInterface {
        fatalError("You have to override this method.")
    }
}
</code></pre><p>That‚Äôs our dynamic plugin interface library, feel free to push this to a remote repository.</p><h2>Building a dynamic plugin</h2><p>For the sake of simplicity we‚Äôll build a module called <code>PluginA</code>, this is the manifest file:</p><pre><code class="language-swift">// swift-tools-version:5.2
import PackageDescription

let package = Package(
    name: "PluginA",
    products: [
        .library(name: "PluginA", type: .dynamic, targets: ["PluginA"]),
    ],
    dependencies: [
        .package(url: "path/to/the/PluginInterface/repository", from: "1.0.0"),
    ],
    targets: [
        .target(name: "PluginA", dependencies: [
            .product(name: "PluginInterface", package: "PluginInterface")
        ]),
    ]
)
</code></pre><p>The plugin implementation will of course implement the <code>PluginInterface</code> protocol. You can extend this protocol based on your needs, you can also use other frameworks as dependencies.</p><pre><code class="language-swift">import PluginInterface

struct PluginA: PluginInterface {

    func foo() -> String {
        return "A"
    }
}
</code></pre><p>We have to subclass the <code>PluginBuilder</code> class and return our plugin implementation. We are going to use the <code>@_cdecl</code> attributed create function to access our plugin builder from the core app. This <a href="https://theswiftdev.com/everything-about-public-and-private-swift-attributes/" target="_blank">Swift attribute</a> tells the compiler to save our function under the ‚ÄúcreatePlugin‚Äù symbol name.</p><pre><code class="language-swift">import PluginInterface

@_cdecl("createPlugin")
public func createPlugin() -> UnsafeMutableRawPointer {
    return Unmanaged.passRetained(PluginABuilder()).toOpaque()
}

final class PluginABuilder: PluginBuilder {

    override func build() -> PluginInterface {
        PluginA()
    }
}
</code></pre><p>We can build the plugin using the command line, just run <code>swift build</code> in the project folder. Now you can find the dylib file under the binary path, feel free to run <code>swift build --show-bin-path</code>, this will output the required folder. We will need both <code>.dylib</code> files for later use.</p><h2>Loading the plugin at runtime</h2><p>The core application will also use the plugin interface as a dependency.</p><pre><code class="language-swift">// swift-tools-version:5.2
import PackageDescription

let package = Package(
    name: "CoreApp",
    dependencies: [
        .package(url: "path/to/the/PluginInterface/repository", from: "1.0.0"),
    ],
    targets: [
        .target(name: "CoreApp", dependencies: [
            .product(name: "PluginInterface", package: "PluginInterface")
        ]),
    ]
)
</code></pre><p>This is an executable target, so we can place the loading logic to the <code>main.swift</code> file.</p><pre><code class="language-swift">import Foundation
import PluginInterface

typealias InitFunction = @convention(c) () -> UnsafeMutableRawPointer

func plugin(at path: String) -> PluginInterface {
    let openRes = dlopen(path, RTLD_NOW|RTLD_LOCAL)
    if openRes != nil {
        defer {
            dlclose(openRes)
        }

        let symbolName = "createPlugin"
        let sym = dlsym(openRes, symbolName)

        if sym != nil {
            let f: InitFunction = unsafeBitCast(sym, to: InitFunction.self)
            let pluginPointer = f()
            let builder = Unmanaged<PluginBuilder>.fromOpaque(pluginPointer).takeRetainedValue()
            return builder.build()
        }
        else {
            fatalError("error loading lib: symbol \(symbolName) not found, path: \(path)")
        }
    }
    else {
        if let err = dlerror() {
            fatalError("error opening lib: \(String(format: "%s", err)), path: \(path)")
        }
        else {
            fatalError("error opening lib: unknown error, path: \(path)")
        }
    }
}

let myPlugin = plugin(at: "path/to/my/plugin/libPluginA.dylib")
let a = myPlugin.foo()
print(a)
</code></pre><p>We can use the <code>dlopen</code> function to open the dynamic library file, then we are trying to get the createPlugin symbol using the <code>dlsym</code> method. If we have a pointer we still need to cast that into a valid <code>PluginBuilder</code> object, then we can call the build method and return the plugin interface.</p><h2>Running the app</h2><p>Now if you try to run this application using Xcode you‚Äôll get a warning like this:</p><blockquote><p>WARN: Class _TtC15PluginInterface13PluginBuilder is implemented in both‚Ä¶ One of the two will be used. Which one is undefined.</p></blockquote><p>This is related to an old bug, but fortunately that is already resolved. This time Xcode is the bad guy, since it is trying to link everything as a static dependency. Now if you build the application through the command line (swift build) and place the following files in the same folder:</p><ul><li>CoreApp</li><li>libPluginA.dylib</li><li>libPluginInterface.dylib</li></ul><p>You can run the application <code>./CoreApp</code> without further issues. The app will print out <code>A</code> without the warning message, since the Swift package manager is recognizing that you would like to link the libPluginInterface framework as a dynamic framework, so it won‚Äôt be embedded into the application binary. Of course you have to set up the right plugin path in the core application.</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
