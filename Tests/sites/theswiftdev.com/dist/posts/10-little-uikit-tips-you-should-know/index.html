<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>10 little UIKit tips you should know - </title>
    <meta name="description" content="In this article I&#39;ve gathered my top 10 favorite modern UIKit tips that I&#39;d definitely want to know before I start my next project.">
    
    <meta property="og:url" content="/posts/10-little-uikit-tips-you-should-know/">
    <meta property="og:title" content="10 little UIKit tips you should know - ">
    <meta property="og:description" content="In this article I&#39;ve gathered my top 10 favorite modern UIKit tips that I&#39;d definitely want to know before I start my next project.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="10 little UIKit tips you should know - ">
    <meta name="twitter:description" content="In this article I&#39;ve gathered my top 10 favorite modern UIKit tips that I&#39;d definitely want to know before I start my next project.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/about/">About</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2022-02-03 16:20:00">2022-02-03 16:20:00</time>
            <h1 class="title">10 little UIKit tips you should know</h1>
            <p class="excerpt">In this article I&#39;ve gathered my top 10 favorite modern UIKit tips that I&#39;d definitely want to know before I start my next project.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Custom UIColor with dark mode support</h2><p>Dark mode and light mode shouldn‚Äôt follow the exact same design patterns, sometimes you‚Äôd like to use a border when your app is in light mode, but in dark mode you might want to hide the extra line.</p><p>One possible solution is to define a custom <a href="https://developer.apple.com/documentation/uikit/uicolor" target="_blank">UIColor</a> based the given UITraitCollection. You can check the userInterfaceStyle property of a trait to check for dark appearance style.</p><pre><code class="language-swift">extension UIColor {
    static var borderColor: UIColor {
        .init { (trait: UITraitCollection) -> UIColor in
            if trait.userInterfaceStyle == .dark {
                return UIColor.clear
            }
            return UIColor.systemGray4
        }
    }
}
</code></pre><p>Based on this condition you can easily return different colors both for light and dark mode. You can create your own set of static color variables by extending the UIColor object. It‚Äôs a must have little trick if you are planning to support dark mode and you‚Äôd like to create custom colors. üåà</p><h2>Observing trait collection changes</h2><p>This next one is also related to dark mode support, sometimes you‚Äôd like to detect appearance changes of the user interface and this is where the traitCollectionDidChange function can be helpful. It‚Äôs available on views, controllers and cells too, so it‚Äôs quite an universal solution.</p><pre><code class="language-swift">class MyCustomView: UIView {
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        guard traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) else {
            return
        }
        layer.borderColor = UIColor.borderColor.cgColor
    }
}
</code></pre><p>For example, inside this function you can check if the trait collection has a different appearance style and you can update your CoreGraphics layers according to that. The CoreGraphics framework is a low level tool and if you work with layers and colors you have to manually update them if it comes to dark mode support, but the traitCollectionDidChange method can help you a lot. üí°</p><h2>UIButton with context menus</h2><p><a href="https://useyourloaf.com/blog/button-configuration-in-ios-15/" target="_blank">Creating buttons got a lot easier with iOS 15</a>, but did you know that you can also use a button to display a context menu? It‚Äôs very easy to present a UIMenu you just have to set the menu and the showsMenuAsPrimaryAction property of the button to true.</p><pre><code class="language-swift">import UIKit

class TestViewController: UIViewController {
    
    weak var button: UIButton!

    override func loadView() {
        super.loadView()
     
        let button = UIButton(frame: .zero)
        button.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(button)
        self.button = button

        NSLayoutConstraint.activate([
            button.centerYAnchor.constraint(equalTo: view.centerYAnchor),
            button.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            button.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            button.heightAnchor.constraint(equalToConstant: 44),
        ])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        button.setTitle("Open menu", for: .normal)
        button.setTitleColor(.systemGreen, for: .normal)
        button.menu = getContextMenu()
        button.showsMenuAsPrimaryAction = true
    }

    func getContextMenu() -> UIMenu {
        .init(title: "Menu",
              children: [
                UIAction(title: "Edit", image: UIImage(systemName: "square.and.pencil")) { _ in
                    print("edit button clicked")
                },
                UIAction(title: "Delete", image: UIImage(systemName: "trash"), attributes: .destructive) { _ in
                    print("delete action")
                },
              ])
    }
    
}
</code></pre><p>This way the UIButton will act as a menu button, you can assign various actions to your menu item. I believe this API is especially handy in some cases, nowadays I prefer to use context menus instead of swipe-to-x-y actions, because it‚Äôs a bit more convenient for the user if we visually show them (usually with 3 dots) that there are additional actions available on a given UI element. üßê</p><h2>Don‚Äôt be afraid of subclassing views</h2><p>UIKit is an OOP framework and I highly recommend to subclass custom views instead of multi-line view configuration code snippets inside your view controller. The previous code snippet is a great example for the opposite, so let‚Äôs fix that real quick.</p><pre><code class="language-swift">import UIKit

class MenuButton: UIButton {

    @available(*, unavailable)
    override init(frame: CGRect) {
        super.init(frame: frame)
        
        self.initialize()
    }

    @available(*, unavailable)
    required public init?(coder: NSCoder) {
        super.init(coder: coder)
        
        self.initialize()
    }
   
    public init() {
        super.init(frame: .zero)
        
        self.initialize()
    }
    
    open func initialize() {
        self.translatesAutoresizingMaskIntoConstraints = false

        setTitle("Open menu", for: .normal)
        setTitleColor(.systemGreen, for: .normal)
        menu = getContextMenu()
        showsMenuAsPrimaryAction = true
    }
    
    func getContextMenu() -> UIMenu {
        .init(title: "Menu",
              children: [
                UIAction(title: "Edit", image: UIImage(systemName: "square.and.pencil")) { _ in
                    print("edit button clicked")
                },
                UIAction(title: "Delete", image: UIImage(systemName: "trash"), attributes: .destructive) { _ in
                    print("delete action")
                },
              ])
    }

    func layoutConstraints(in view: UIView) -> [NSLayoutConstraint] {
        [
            centerYAnchor.constraint(equalTo: view.centerYAnchor),
            leadingAnchor.constraint(equalTo: view.leadingAnchor),
            trailingAnchor.constraint(equalTo: view.trailingAnchor),
            heightAnchor.constraint(equalToConstant: 44),
        ]
    }
}


class TestViewController: ViewController {
    
    weak var button: MenuButton!

    override func loadView() {
        super.loadView()
     
        let button = MenuButton()
        view.addSubview(button)
        self.button = button
        NSLayoutConstraint.activate(button.layoutConstraints(in: view))
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        
    }
}
</code></pre><p>As you can see the code inside the view controller is heavily reduced and most of the button configuration related logic is now encapsulated inside the MenuButton subclass. This approach is great because you can focus less on view configuration and more on your business logic inside the view controller. It‚Äôll also help you to think in reusable components.</p><p>One additional note here is that I tend to create my interfaces from code that‚Äôs why I mark the unnecessary init methods with the @available(*, unavailable) flag so other people in my team can‚Äôt call them accidentally, but this is just a personal preference. üòÖ</p><h2>Always large navigation title</h2><p>I don‚Äôt know about you, but for me all the apps have glitches if it comes to the large title feature in the navigation bar. For personal projects I‚Äôve got sick and tired of this and I simply force the large title display mode. It‚Äôs relatively simple, here‚Äôs how to do it.</p><pre><code class="language-swift">import UIKit

class TestNavigationController: UINavigationController {

    override init(rootViewController: UIViewController) {
        super.init(rootViewController: rootViewController)
        
        initialize()
    }

    @available(*, unavailable)
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)

        initialize()
    }
    
    open func initialize() {
        navigationBar.prefersLargeTitles = true
        navigationItem.largeTitleDisplayMode = .always
        
        // custom tint color
        navigationBar.tintColor = .systemGreen
        // custom background color
        let navBarAppearance = UINavigationBarAppearance()
        navBarAppearance.backgroundColor = .systemBackground
        navigationBar.standardAppearance = navBarAppearance
        navigationBar.scrollEdgeAppearance = navBarAppearance
    }
}

class TestViewController: UIViewController {
    
    override func loadView() {
        super.loadView()
        
        // prevent collapsing the navbar if we add scrollviews
        view.addSubview(UIView(frame: .zero))
        
        // add other custom views...
    }
}

let controller = TestNavigationController(rootViewController: TestViewController())
</code></pre><p>You just have to set two properties (you can subclass UINavigationController or set these inside your view controller, but I prefer subclassing) plus you have to add an empty view to your view hierarchy to prevent collapsing if you are planning to use a UIScrollView, UITableView or UICollectionView inside the view controller.</p><p>Since this tip is also based on my personal preference, I‚Äôve also included a few more customization options in the snippet. If you take a look at the initialize method you can see how to change the tint color and the background color of the navigation bar. üëç</p><h2>Custom separators for navigation and tab bars</h2><p>Since many apps prefer to have a customized navigation bar and tab bar appearance it‚Äôs quite a common practice when you have to also add a separator line to distinguish user interface elements a bit more. This is how you can solve it by using a single bar separator class.</p><pre><code class="language-swift">import UIKit 

class BarSeparator: UIView {
    
    let height: CGFloat = 0.3

    init() {
        super.init(frame: CGRect(x: 0, y: 0, width: 0, height: height))
        
        translatesAutoresizingMaskIntoConstraints = false
        backgroundColor = .systemGray4
    }
    
    @available(*, unavailable)
    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }
    
    func layoutConstraints(for navigationBar: UINavigationBar) -> [NSLayoutConstraint] {
        [
            widthAnchor.constraint(equalTo: navigationBar.widthAnchor),
            heightAnchor.constraint(equalToConstant: CGFloat(height)),
            centerXAnchor.constraint(equalTo: navigationBar.centerXAnchor),
            topAnchor.constraint(equalTo: navigationBar.bottomAnchor),
        ]
    }
    
    func layoutConstraints(for tabBar: UITabBar) -> [NSLayoutConstraint] {
        [
            widthAnchor.constraint(equalTo: tabBar.widthAnchor),
            heightAnchor.constraint(equalToConstant: CGFloat(height)),
            centerXAnchor.constraint(equalTo: tabBar.centerXAnchor),
            topAnchor.constraint(equalTo: tabBar.topAnchor),
        ]
    }
}

class MyNavigationController: UINavigationController {
    
   override func viewDidLoad() {
        super.viewDidLoad()
        
        let separator = BarSeparator()
        navigationBar.addSubview(separator)
        NSLayoutConstraint.activate(separator.layoutConstraints(for: navigationBar))
    }
}

class MyTabBarController: UITabBarController {
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        let separator = BarSeparator()
        tabBar.addSubview(separator)
        NSLayoutConstraint.activate(separator.layoutConstraints(for: tabBar))
    }   
}
</code></pre><p>This way you can reuse the BarSeparator component to add a line to the bottom of a navigation bar and to the top of a tab bar. This snippet follows the exact same principles that I showed you before, so you should be familiar with the subclassing concepts by now. ü§ì</p><h2>Custom tab bar items</h2><p>I struggled quite a lot with tab bar item icon alignment, but this the way I can easily show / hide the title and align the icons to the center of the bar if there are no labels.</p><pre><code class="language-swift">import UIKit

class MyTabBarItem: UITabBarItem {
    
    override var title: String? {
        get { hideTitle ? nil : super.title }
        set { super.title = newValue }
    }
        
    private var hideTitle: Bool {
        true
    }

    private func offset(_ image: UIImage?) -> UIImage? {
        if hideTitle {
            return image?.withBaselineOffset(fromBottom: 12)
        }
        return image
    }
    
    // MARK: - init
    
    public convenience init(title: String?, image: UIImage?, selectedImage: UIImage?) {
        self.init()

        self.title = title
        self.image = offset(image)
        self.selectedImage = offset(selectedImage)
    }

    override init() {
        super.init()
    }

    @available(*, unavailable)
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

// inside some view controller init
tabBarItem = MyTabBarItem(title: "Home", image: UIImage(systemName: "house"), selectedImage: nil)
</code></pre><p>I‚Äôd also like to mention that <a href="https://developer.apple.com/sf-symbols/" target="_blank">SF Symbols</a> are amazing. If you are not using these kind of icons just yet I highly recommend to take a look. Apple made a really nice job with this collection, there are so many lovely icons that you can use to visually enrich your app, so don‚Äôt miss out. üòä</p><h2>loadView vs viewDidLoad</h2><p>Long story short, you should always instantiate and place constraints to your views inside the <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621454-loadview" target="_blank">loadView</a> method and configure your views inside the <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621495-viewdidload" target="_blank">viewDidLoad</a> function.</p><p>I always use implicitly unwrapped weak optional variables for custom views, since the <a href="https://developer.apple.com/documentation/uikit/uiview/1622616-addsubview" target="_blank">addSubview</a> function will create a strong reference to the view when it is added to the view hierarchy. We don‚Äôt want to have retain cycles, right? That‚Äôd be real bad for our application. üôÉ</p><pre><code class="language-swift">import UIKit

class MyCollectionViewController: ViewController {
    
    weak var collection: UICollectionView!

    override func loadView() {
        super.loadView()
        
        view.addSubview(UIView(frame: .zero))
        
        let collection = UICollectionView(frame: .zero, collectionViewLayout: UICollectionViewFlowLayout())
        collection.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(collection)
        self.collection = collection
        NSLayoutConstraint.activate([
            // ...
        ])
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        collection.backgroundColor = .systemBackground
        collection.alwaysBounceVertical = true
        collection.dragInteractionEnabled = true
        collection.dragDelegate = self
        collection.dropDelegate = self

        if let flowLayout = collection.collectionViewLayout as? UICollectionViewFlowLayout {
            flowLayout.sectionHeadersPinToVisibleBounds = true
        }
        
        collection.register(MyCell.self,
                            forCellWithReuseIdentifier: MyCell.identifier)
    }
</code></pre><p>Anyway, I‚Äôd go with a custom subclass for the collection view here as well and maybe define a configure method then call that one instead of placing everything directly to the controller. The decision is always up-to-you, I‚Äôm just trying to show you the some possible solutions. üòâ</p><h2>Stack views & auto-layout anchors</h2><p>Take advantage of stack views and auto layout anchors as much as possible. If you are going to create user interfaces programmatically in Swift with the help of UIKit, then it‚Äôs going to be an essential skill to master these techniques otherwise you‚Äôre going to struggle a lot.</p><p>I already have a tutorial about <a href="https://theswiftdev.com/ios-auto-layout-tutorial-programmatically/" target="_blank">using auto layout programmatically</a> and another one about <a href="https://theswiftdev.com/mastering-ios-auto-layout-anchors-programmatically-from-swift/" target="_blank">mastering auto-layout anchors</a>, they were published a few years ago, but the concepts are still valid and the code still works. I also have one more article that you should read if you want to learn <a href="https://theswiftdev.com/custom-views-input-forms-and-mistakes/" target="_blank">about building forms using stack views</a>. Learning these kind of things helped me a lot to create complex screens hassle-free. I‚Äôm also using one more <a href="https://theswiftdev.com/ultimate-uicollectionview-guide-with-ios-examples-written-in-swift/" target="_blank">‚Äúbest practice‚Äù to create collection views</a>.</p><p>When SwiftUI came out I had the feeling that eventually I‚Äôd do the same with UIKit, but of course Apple had the necessary tooling to support the framework with view builders and property wrappers. Now that we have SwiftUI I‚Äôm still not using it because I feel like it lacks quite a lot of features even in 2022. I know it‚Äôs great and I‚Äôve created several prototypes for screens using it, but if it comes to a complex application my gut tells me that I should still go with UIKit. ü§ê</p><h2>Create a reusable components library</h2><p>My final advice in this tutorial is that you should build a custom Swift package and move all your components there. Maybe for the first time it‚Äôs going to consume quite a lot of time but if you are working on multiple projects it will speed up development process for your second, third, etc. app.</p><p>You can move all your custom base classes into a separate library and create specific ones for your application. You just have to mark them open, you can use the availability API to manage what can be used and what should be marked as unavailable.</p><p>I have quite a lot of tutorials about the <a href="https://theswiftdev.com/swift-package-manager-tutorial/" target="_blank">Swift Package Manager</a> on my blog, this is a great way to get familiar with it and you can start building your own library step-by-step. üòä</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
