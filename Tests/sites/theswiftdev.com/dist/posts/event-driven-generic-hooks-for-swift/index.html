<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Event-driven generic hooks for Swift - </title>
    <meta name="description" content="In this article I am going to show you how to implement a basic event processing system for your modular Swift application.">
    
    <meta property="og:url" content="/posts/event-driven-generic-hooks-for-swift/">
    <meta property="og:title" content="Event-driven generic hooks for Swift - ">
    <meta property="og:description" content="In this article I am going to show you how to implement a basic event processing system for your modular Swift application.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Event-driven generic hooks for Swift - ">
    <meta name="twitter:description" content="In this article I am going to show you how to implement a basic event processing system for your modular Swift application.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/about/">About</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2020-11-27 16:20:00">2020-11-27 16:20:00</time>
            <h1 class="title">Event-driven generic hooks for Swift</h1>
            <p class="excerpt">In this article I am going to show you how to implement a basic event processing system for your modular Swift application.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>Dependencies, protocols and types</h2><p>When we write Swift, we can import frameworks and other third party libraries. It‚Äôs quite natural, just think about Foundation, UIKit or nowadays it‚Äôs more likely SwiftUI, but there are many other dependencies that we can use. Even when we don‚Äôt import anything we usually create separate structures or classes to build smaller components instead of one gigantic spaghetti-like file, function or whatever. Consider the following example:</p><pre><code class="language-swift">struct NameProvider {
    func getName() -> String { "John Doe" }
}


struct App {
    let provider = NameProvider()
    
    func run() {
        let name = provider.getName()
        print("Hello \(name)!")
    }
}

let app = App()
app.run()
</code></pre><p>It shows us the basics of the <a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank">separation of concerns</a> principle. The App struct the representation of our main application, which is a simple ‚ÄúHello World!‚Äù app, with a twist. The name is not hardcoded into the App object, but it‚Äôs coming from a NameProvider struct.</p><p>The thing that you should notice is that we‚Äôve created a static dependency between the App and the NameProvider object here. We don‚Äôt have to import a framework to create a dependency, these objects are in the same namespace, but still the application will always require the NameProvider type at compilation time. This is not bad, but sometimes it‚Äôs not what we really want.</p><p>How can we solve this? Wait I have an idea, let‚Äôs create a protocol! üòÉ</p><pre><code class="language-swift">import Foundation

struct MyNameProvider: NameProvider {
    func getName() -> String { "John Doe" }
}


protocol NameProvider {
    func getName() -> String
}

struct App {
    let provider: NameProvider
    
    func run() {
        let name = provider.getName()
        print("Hello \(name)!")
    }
}

let provider = MyNameProvider()
let app = App(provider: provider)
app.run()
</code></pre><p>Oh no, this just made our entire codebase a bit harder to understand, also didn‚Äôt really solved anything, because we still can‚Äôt compile our application without the MyNameProvider dependency. That class must be part of the package no matter how many protocols we create. Of course we could move the NameProvider protocol into a standalone <a href="https://theswiftdev.com/swift-package-manager-tutorial/" target="_blank">Swift package</a>, then we could create another package for the protocol implementation that relies on that one, then use both as a dependency when we build our application, but hey isn‚Äôt this getting a little bit complicated? ü§î</p><p>What did we gain here? First of all we overcomplicated a really simple thing. On the other hand, we eliminated an actual dependency from the App struct itself. That‚Äôs a great thing, because now we could create a mock name provider and test our application instance with that, we can <a href="https://theswiftdev.com/swift-dependency-injection-design-pattern/" target="_blank">inject any kind of Swift object</a> into the app that conforms to the NameProvider protocol.</p><p>Can we change the provider at runtime? Well, yes, that‚Äôs also possible we could define the provider as a variable and alter its value later on, but there‚Äôs one thing that we can‚Äôt solve with this approach.</p><p><strong>We can‚Äôt move out the provider reference from the application itself.</strong> üò≥</p><h2>Event-driven architecture</h2><p>The EDA design pattern allows us to create loosely coupled software components and services without forming an actual dependency between the participants. Consider the following alternative:</p><pre><code class="language-swift">struct MyNameProvider {
    func getName(_: HookArguments) -> String { "John Doe" }
}

struct App {

    func run() {
        guard let name: String = hooks.invoke("name-event") else {
            fatalError("Someone must provide a name-event handler.")
        }
        print("Hello \(name)!")
    }
}

let hooks = HookStorage()

let provider = MyNameProvider()
hooks.register("name-event", use: provider.getName)

let app = App()
app.run()
</code></pre><p>Don‚Äôt try to compile this yet, there are some additional things that we‚Äôll need to implement, but first I am going to explain this snippet step-by-step. The MyNameProvider struct getName function signature changed a bit, because in an event-driven world we need a unified function signature to handle all kind of scenarios. Fortunately we don‚Äôt have to erease the return type to Any thanks to the amazing generic support in Swift. This HookArguments type will be just an alias for a dictionary that has String keys and it can have Any value.</p><p>Now inside the App struct we call-out for the hook system and invoke an event with the ‚Äúname-event‚Äù name. The invoke method is a function with a generic return type, it actually returns an optional generic value, hence the guard statement with the explicit String type. Long story short, we call something that can return us a String value, in other words we fire the name event. üî•</p><p>The very last part is the setup, first we need to initialize our hook system that will store all the references for the event handlers. Next we create a provider and register our handler for the given event, finally we make the app and run everything.</p><p>I‚Äôm not saying that this approach is less complicated than the protocol oriented version, but it‚Äôs very different for sure. Unfortunately we still have to build our event handler system, so let‚Äôs get started.</p><pre><code class="language-swift">public typealias HookArguments = [String: Any]

/// a hook function is something that can be invoked with a given arguments
public protocol HookFunction {
    func invoke(_: HookArguments) -> Any
}

/// a hook function signature with a generic return type
public typealias HookFunctionSignature<T> = (HookArguments) -> T
</code></pre><p>As I mentioned this before, the HookArguments is just a typealias for the [String:Any] type, this way we are going to be able to pass around any kind of values under given keys for the hook functions. Next we define a protocol for invoking these functions, and finally we build up a function signature for our hooks, this is going to be used during the registration process. ü§ì</p><pre><code class="language-swift">public struct AnonymousHookFunction: HookFunction {

    private let functionBlock: HookFunctionSignature<Any>

    /// anonymous hooks can be initialized using a function block
    public init(_ functionBlock: @escaping HookFunctionSignature<Any>) {
        self.functionBlock = functionBlock
    }

    /// since they are hook functions they can be invoked with a given argument
    public func invoke(_ args: HookArguments) -> Any {
        functionBlock(args)
    }
}
</code></pre><p>The AnonymousHookFunction is a helper that we can use to pass around blocks instead of object pointers when we register a new hook function. It can be quite handy sometimes to write an event handler without creating additional classes or structs. We are going to also need to associate these hook function pointers with an event name and an actual a return type‚Ä¶</p><pre><code class="language-swift">public final class HookFunctionPointer {

    public var name: String
    public var pointer: HookFunction
    public var returnType: Any.Type
    
    public init(name: String, function: HookFunction, returnType: Any.Type) {
        self.name = name
        self.pointer = function
        self.returnType = returnType
    }
}
</code></pre><p>The HookFunctionPointer is used inside the hook storage, that‚Äôs the core building block for this entire system. The hook storage is the place where all your event handlers live and you can call these events through this storage pointer when you need to trigger an event. üî´</p><pre><code class="language-swift">public final class HookStorage {
    
    private var pointers: [HookFunctionPointer]

    public init() {
        self.pointers = []
    }

    public func register<ReturnType>(_ name: String, use block: @escaping HookFunctionSignature<ReturnType>) {
        let function = AnonymousHookFunction { args -> Any in
            block(args)
        }
        let pointer = HookFunctionPointer(name: name, function: function, returnType: ReturnType.self)
        pointers.append(pointer)
    }

    /// invokes the first hook function with a given name and the provided arguments
    public func invoke<ReturnType>(_ name: String, args: HookArguments = [:]) -> ReturnType? {
        pointers.first { $0.name == name && $0.returnType == ReturnType.self }?.pointer.invoke(args) as? ReturnType
    }

    /// invokes all the available hook functions with a given name
    public func invokeAll<ReturnType>(_ name: String, args: HookArguments = [:]) -> [ReturnType] {
        pointers.filter { $0.name == name && $0.returnType == ReturnType.self }.compactMap { $0.pointer.invoke(args) as? ReturnType }
    }
}
</code></pre><p>I know, this seems like quite complicated at first sight, but when you start playing around with these methods it‚Äôll all make sense. I‚Äôm still not sure about the naming conventions, for example the HookStorage is also a global event storage so maybe it‚Äôd be better to call it something related to the event term. If you have a better idea, feel free to <a href="https://x.com/tiborbodecs" target="_blank">tweet me</a>.</p><p>Oh, I almost forgot that I wanted to show you how to register an anonymous hook function. üòÖ</p><pre><code class="language-swift">hooks.register("name-event") { _ in "John Doe" }
</code></pre><p>That‚Äôs it you don‚Äôt event have to write the return type, the Swift compiler this time is smart enough to figure out the final function signature. This magic only works with one-liners I suppose‚Ä¶ ‚ú®</p><p>This article was a follow-up on <a href="https://theswiftdev.com/modules-and-hooks-in-swift/" target="_blank">the modules and hooks in Swift</a>, also heavily inspired by the my old Entropy framework, Drupal and the <a href="https://www.sitepoint.com/wordpress-hook-system/" target="_blank">Wordpress</a> hook systems. The code implementation idea comes from the <a href="https://github.com/vapor/vapor/tree/master/Sources/Vapor/Routing" target="_blank">Vapor‚Äôs routing abstraction</a>, but it‚Äôs slightly changed to match my needs.</p><p>The event-driven design approach is a very nice architecture and I really hope that we‚Äôll see the long term benefit of using this pattern inside <a href="https://github.com/binarybirds/feather/" target="_blank">Feather</a>. I can‚Äôt wait to tell you more about it‚Ä¶ ü™∂</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
