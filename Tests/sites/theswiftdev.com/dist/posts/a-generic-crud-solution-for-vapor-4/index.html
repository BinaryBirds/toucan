<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>A generic CRUD solution for Vapor 4 - </title>
    <meta name="description" content="Learn how to build a controller component that can serve models as JSON objects through a RESTful API written in Swift.">
    
    <meta property="og:url" content="/posts/a-generic-crud-solution-for-vapor-4/">
    <meta property="og:title" content="A generic CRUD solution for Vapor 4 - ">
    <meta property="og:description" content="Learn how to build a controller component that can serve models as JSON objects through a RESTful API written in Swift.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="A generic CRUD solution for Vapor 4 - ">
    <meta name="twitter:description" content="Learn how to build a controller component that can serve models as JSON objects through a RESTful API written in Swift.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/about/">About</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2020-04-01 16:20:00">2020-04-01 16:20:00</time>
            <h1 class="title">A generic CRUD solution for Vapor 4</h1>
            <p class="excerpt">Learn how to build a controller component that can serve models as JSON objects through a RESTful API written in Swift.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>CRUD ~ Create, Read, Update and Delete</h2><p>We should start by implementing the non-generic version of our code, so after we see the pattern we can turn it into a more generalized Swift code. If you start with the <a href="https://github.com/vapor/api-template" target="_blank">API template</a> project there is a pretty good example for almost everything using a Todo model.</p><blockquote><p>NOTE: Start a new project using the <a href="http://docs.vapor.codes/3.0/getting-started/toolbox/" target="_blank">toolbox</a>, just run <code>vapor new myProject</code></p></blockquote><p>Open the project by double clicking the <code>Package.swift</code> file, that‚Äôll fire up Xcode (you should be on version 11.4 or later). If you open the <code>Sources/App/Controllers</code> folder you‚Äôll find a sample controller file there called <code>TodoController.swift</code>. We‚Äôre going to work on this, but first‚Ä¶</p><blockquote><p>A controller is a collection of request handler functions around a specific model.</p></blockquote><h2>HTTP basics: Request -> Response</h2><p><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank">HTTP</a> is a text transfer protocol that is widely used around the web. In the beginning it was only used to transfer HTML files, but nowadays you can use it to request almost anything. It‚Äôs mostly a stateless protocol, this means you request something, you get back a response and that‚Äôs it.</p><p>It‚Äôs like ordering a pizza from a place through phone. You need a number to call (URL), you pick up the phone, dial the place, the phone company initializes the connection between (you & the pizza place) the two participants (the network layer does the same thing when you request an URL from a server). The phone on the other side starts ringing. üì±</p><p>Someone picks up the phone. You both introduce yourselves, also exchange some basic info such as the delivery address (server checks HTTP headers & discovers what needs to be delivered to where). You tell the place what kind of pizza you‚Äôd like to have & you wait for it. The place cooks the pizza (the server gathers the necessary data for the response) & the pizza boy arrives with your order (the server sends back the actual response). üçï</p><blockquote><p>Everything happens asynchronously, the place (server) can fulfill multiple requests. If there is only one person who is taking orders & cooking pizzas, sometimes the cooking process will be blocked by answering the phone. Anyways, using non-blocking i/o is important, that‚Äôs why Vapor uses Futures & Promises from <a href="https://github.com/apple/swift-nio" target="_blank">SwiftNIO</a> under the hood.</p></blockquote><p>In our case the request is a URL with some extra headers (key, value pairs) and a request body object (encoded data). The response is usually made of a HTTP status code, optional headers and response body. If we are talking about a RESTful API, the encoding of the body is usually JSON.</p><p>All right then, now you know the basics it‚Äôs time to look at some Swift code.</p><h2>Contents and models in Vapor</h2><p>Defining a data structure in Swift is pretty easy, you just have to create a struct or a class. You can also convert them back and forth to JSON using the built-in <a href="https://theswiftdev.com/how-to-parse-json-in-swift-using-codable-protocol/" target="_blank">Codable protocol</a>. Vapor has an extension around this called Content. If you conform the the protocol (no need to implement any new functions, the object just needs to be Codable) the system can decode these objects from requests and encode them as responses.</p><p>Models on the other hand represent rows from your database. The <a href="https://theswiftdev.com/a-tutorial-for-beginners-about-the-fluent-postgresql-driver-in-vapor-4/" target="_blank">Fluent</a> ORM layer can take care of the low level abstractions, so you don‚Äôt have to mess around with SQL queries. This is a great thing to have, read my other article if you like to know more about Fluent. üíæ</p><p>The problem starts when you have a model and it has different fields than the content. Imagine if this Todo model was a User model with a secret password field? Would you like to expose that to the public when you encode it as a response? Nope, I don‚Äôt think so. üôâ</p><p>I believe that in most of the Cases the Model and the Content should be separated. Taking this one step further, the content of the request (input) and the content of the response (output) is sometimes different. I‚Äôll stop it now, let‚Äôs change our Todo model according to this.</p><pre><code class="language-swift">import Fluent
import Vapor

final class Todo: Model {
    
    struct Input: Content {
        let title: String
    }

    struct Output: Content {
        let id: String
        let title: String
    }
    
    static let schema = "todos"

    @ID(key: .id) var id: UUID?
    @Field(key: "title") var title: String

    init() { }

    init(id: UUID? = nil, title: String) {
        self.id = id
        self.title = title
    }
}
</code></pre><p>We expect to have a title when we insert a record (we can generate the id), but when we‚Äôre returning Todos we can expose the id property as well. Now back to the controller.</p><blockquote><p>WARN: Don‚Äôt forget to run Fluent migrations first: <code>swift run Run migrate</code></p></blockquote><h3>Create</h3><p>The flow is pretty simple. Decode the Input type from the content of the request (it‚Äôs created from the HTTP body) and use it to construct a new Todo class. Next save the newly created item to the database using Fluent. Finally after the save operation is done (it returns nothing by default), map the future into a proper Output, so Vapor can encode this to JSON format.</p><pre><code class="language-swift">import Fluent
import Vapor

struct TodoController {

    /*
         curl -i -X POST "http://127.0.0.1:8080/todos" \
         -H "Content-Type: application/json" \
         -d '{"title": "Hello World!"}'
     */
    func create(req: Request) throws -> EventLoopFuture<Todo.Output> {
        let input = try req.content.decode(Todo.Input.self)
        let todo = Todo(title: input.title)
        return todo.save(on: req.db)
            .map { Todo.Output(id: todo.id!.uuidString, title: todo.title) }
    }

    // ...
}
</code></pre><p>I prefer cURL to quickly check my endpoints, but you can also create unit tets for this purpose. Run the server using Xcode or type <code>swift run Run</code> to the command line. Next if you copy & paste the commented snippet it should create a new todo item and return the output with some additional HTTP info. You should also validate the input, but this time let‚Äôs just skip that part. üòÖ</p><h3>Read</h3><p>Getting back all the <code>Todo</code> objects is a simple task, but returning a paged response is not so obvious. Fortunately with Fluent 4 we have a built-in solution for this. Let me show you how it works, but first I‚Äôd like to alter the routes a little bit.</p><pre><code class="language-swift">import Fluent
import Vapor

func routes(_ app: Application) throws {
    let todoController = TodoController()
    app.post("todos", use: todoController.create)
    app.get("todos", use: todoController.readAll)
    app.get("todos", ":id", use: todoController.read)
    app.post("todos", ":id", use: todoController.update)
    app.delete("todos", ":id", use: todoController.delete)
}
</code></pre><p>As you can see I tend to use read instead of index, plus <code>:id</code> is a much shorter parameter name, plus I‚Äôll already know the returned model type based on the context, no need for additional prefixes here. Ok, let me show you the controller code for the read endpoints:</p><pre><code class="language-swift">struct TodoController {

    /*
       curl -i -X GET "http://127.0.0.1:8080/todos?page=2&per=2" \
        -H "Content-Type: application/json"
    */
    func readAll(req: Request) throws -> EventLoopFuture<Page<Todo.Output>> {
        return Todo.query(on: req.db).paginate(for: req).map { page in
            page.map { Todo.Output(id: $0.id!.uuidString, title: $0.title) }
        }
    }

    //...
}
</code></pre><p>As I mentioned this before Fluent helps with pagination. You can use the <code>page</code> and <code>per</code> query parameters to retrieve a page with a given number of elements. The newly returned response will contain two new (<code>items</code> & <code>metadata</code>) keys. Metadata inclues the total number of items in the database. If you don‚Äôt like the metadata object you can ship your own paginator:</p><pre><code class="language-swift">// the first 10 items
Todo.query(on: req.db).range(..<10)

// returns 10 items from the 2nd element
Todo.query(on: req.db).range(2..<10).all()

// limit - offset
Todo.query(on: req.db).range(offset..<limit).all()

// page - per
Todo.query(on: req.db).range(((page - 1) * per)..<(page * per)).all()
The QueryBuilder range support is a great addition. Now let's talk about reading one element.

struct TodoController {

    /*
        curl -i -X GET "http://127.0.0.1:8080/todos/<id>" \
            -H "Content-Type: application/json"
     */
    func read(req: Request) throws -> EventLoopFuture<Todo.Output> {
        guard let id = req.parameters.get("id", as: UUID.self) else {
            throw Abort(.badRequest)
        }
        return Todo.find(id, on: req.db)
            .unwrap(or: Abort(.notFound))
            .map { Todo.Output(id: $0.id!.uuidString, title: $0.title) }
    }

    //...
}
</code></pre><p>You can get named parameters by key, I already mentioned this in my <a href="https://theswiftdev.com/beginners-guide-to-server-side-swift-using-vapor-4/" target="_blank">beginner‚Äôs guide article</a>. The new thing here is that you can <code>throw Abort(error)</code> anytime you want to break something. Same thing happens in the <code>unwrap</code> method, that just checks if the value wrapped inside the future object. If it is <code>nil</code> it‚Äôll throws the given error, if the value is present the promise chain will continue.</p><h3>Update</h3><p>Update is pretty straightforward, it‚Äôs somewhat the combination of the read & create methods.</p><pre><code class="language-swift">struct TodoController {

    /*
        curl -i -X POST "http://127.0.0.1:8080/todos/<id>" \
            -H "Content-Type: application/json" \
            -d '{"title": "Write Vapor 4 book"}'
     */
    func update(req: Request) throws -> EventLoopFuture<Todo.Output> {
        guard let id = req.parameters.get("id", as: UUID.self) else {
            throw Abort(.badRequest)
        }
        let input = try req.content.decode(Todo.Input.self)
        return Todo.find(id, on: req.db)
            .unwrap(or: Abort(.notFound))
            .flatMap { todo in
                todo.title = input.title
                return todo.save(on: req.db)
                    .map { Todo.Output(id: todo.id!.uuidString, title: todo.title) }
            }
    }
    
    //...
}
</code></pre><p>You need an id to find the object in the database, plus some input to update the fields. You fetch the item, update the corresponding properties based on the input, save the model and finally return the newly saved version as a public output object. Piece of cake. üç∞</p><h3>Delete</h3><p>Delete is just a little bit tricky, since usually you don‚Äôt return anything in the body, but just a simple status code. Vapor has a nice <code>HTTPStatus</code> enum for this purpose, so e.g. <code>.ok</code> is 200.</p><pre><code class="language-swift">struct TodoController {

    /*
        curl -i -X DELETE "https://127.0.0.1:8080/todos/<id>"
     */
    func delete(req: Request) throws -> EventLoopFuture<HTTPStatus> {
        guard let id = req.parameters.get("id", as: UUID.self) else {
            throw Abort(.badRequest)
        }
        return Todo.find(id, on: req.db)
            .unwrap(or: Abort(.notFound))
            .flatMap { $0.delete(on: req.db) }
            .map { .ok }
    }

    //...
}
</code></pre><p>Pretty much that sums everything. Of course you can extend this with a PATCH method, but that‚Äôs quite a good task for practicing. I‚Äôll leave this ‚Äúunimplemented‚Äù just for you‚Ä¶ üòà</p><h2>A protocol oriented generic CRUD</h2><p>Long story short, if you introduce new models you‚Äôll have to do this exact same thing over and over again if you want to have CRUD endpoints for every single one of them.</p><p>That‚Äôs a boring task to do, plus you‚Äôll end up having a lot of boilerplate code. So why not come up with a more generic solution, right? I‚Äôll show you one possible implementation.</p><pre><code class="language-swift">protocol ApiModel: Model {
    associatedtype Input: Content
    associatedtype Output: Content

    init(_: Input) throws
    var output: Output { get }
    func update(_: Input) throws
}
</code></pre><p>The first thing I did is that I created a new protocol called ApiModel, it has two <code>associatedType</code> requirements, those are the i/o structs from the non-generic example. I also want to be able to initialize or update a model using an <code>Input</code> type, and transform it to an <code>Output</code>.</p><pre><code class="language-swift">protocol ApiController {
    var idKey: String { get }

    associatedtype Model: ApiModel

    // generic helper functions
    func getId(_: Request) throws -> Model.IDValue
    func find(_: Request) throws -> EventLoopFuture<Model>

    // generic crud methods
    func create(_: Request) throws -> EventLoopFuture<Model.Output>
    func readAll(_: Request) throws -> EventLoopFuture<Page<Model.Output>>
    func read(_: Request) throws -> EventLoopFuture<Model.Output>
    func update(_: Request) throws -> EventLoopFuture<Model.Output>
    func delete(_: Request) throws -> EventLoopFuture<HTTPStatus>
    
    // router helper
    @discardableResult
    func setup(routes: RoutesBuilder, on endpoint: String) -> RoutesBuilder
}
</code></pre><p>Next thing todo (haha) is to come up with a controller interface. This is also going to be ‚Äúgeneric‚Äù, plus I‚Äôd like to be able to set a custom id parameter key. One small thing here is that you can‚Äôt 100% generalize the decoding of the identifier parameter, but only if it‚Äôs <code>LosslessStringConvertible</code>.</p><pre><code class="language-swift">extension ApiController where Model.IDValue: LosslessStringConvertible {

    func getId(_ req: Request) throws -> Model.IDValue {
        guard let id = req.parameters.get(self.idKey, as: Model.IDValue.self) else {
            throw Abort(.badRequest)
        }
        return id
    }
}
</code></pre><p>Trust me in 99.9% of the cases you‚Äôll be just fine right with this. Final step is to have a generic version of what we‚Äôve just made above with each CRUD endpoint. üëª</p><pre><code class="language-swift">extension ApiController {
    
    var idKey: String { "id" }

    func find(_ req: Request) throws -> EventLoopFuture<Model> {
        Model.find(try self.getId(req), on: req.db).unwrap(or: Abort(.notFound))
    }

    func create(_ req: Request) throws -> EventLoopFuture<Model.Output> {
        let request = try req.content.decode(Model.Input.self)
        let model = try Model(request)
        return model.save(on: req.db).map { _ in model.output }
    }
    
    func readAll(_ req: Request) throws -> EventLoopFuture<Page<Model.Output>> {
        Model.query(on: req.db).paginate(for: req).map { $0.map { $0.output } }
    }

    func read(_ req: Request) throws -> EventLoopFuture<Model.Output> {
        try self.find(req).map { $0.output }
    }

    func update(_ req: Request) throws -> EventLoopFuture<Model.Output> {
        let request = try req.content.decode(Model.Input.self)
        return try self.find(req).flatMapThrowing { model -> Model in
            try model.update(request)
            return model
        }
        .flatMap { model in
            return model.update(on: req.db).map { model.output }
        }
    }
    
    func delete(_ req: Request) throws -> EventLoopFuture<HTTPStatus> {
        try self.find(req).flatMap { $0.delete(on: req.db) }.map { .ok }
    }
    
    @discardableResult
    func setup(routes: RoutesBuilder, on endpoint: String) -> RoutesBuilder {
        let base = routes.grouped(PathComponent(stringLiteral: endpoint))
        let idPathComponent = PathComponent(stringLiteral: ":\(self.idKey)")
        
        base.post(use: self.create)
        base.get(use: self.readAll)
        base.get(idPathComponent, use: self.read)
        base.post(idPathComponent, use: self.update)
        base.delete(idPathComponent, use: self.delete)

        return base
    }
}
</code></pre><p>Example time. Here is our generic model:</p><pre><code class="language-swift">final class Todo: ApiModel {
    
    struct _Input: Content {
        let title: String
    }

    struct _Output: Content {
        let id: String
        let title: String
    }
    
    typealias Input = _Input
    typealias Output = _Output
    
    // MARK: - model

    static let schema = "todos"

    @ID(key: .id) var id: UUID?
    @Field(key: "title") var title: String

    init() { }

    init(id: UUID? = nil, title: String) {
        self.id = id
        self.title = title
    }
    
    // MARK: - api
    
    init(_ input: Input) throws {
        self.title = input.title
    }
    
    func update(_ input: Input) throws {
        self.title = input.title
    }
    
    var output: Output {
        .init(id: self.id!.uuidString, title: self.title)
    }
}
</code></pre><blockquote><p>NOTE: If the input is the same as the output, you just need one (<code>Context</code>?) struct instead of two.</p></blockquote><p>This is what‚Äôs left off the controller (not much, haha):</p><pre><code class="language-swift">struct TodoController: ApiController {
    typealias Model = Todo
}
</code></pre><p>The router object also shortened a bit:</p><pre><code class="language-swift">func routes(_ app: Application) throws {
    let todoController = TodoController()
    todoController.setup(routes: routes, on: "todos")
}
</code></pre><p>Try to run the app, everything should work just as before.</p><p>This means that you don‚Äôt have to write controllers anymore? Yes, mostly, but still this method lacks a few things, like fetching child objects for nested models or relations. If you are fine with that please go ahead and copy & paste the snippets into your codebase. You won‚Äôt regret, because this code is as simple as possible, plus you can override everything in your controller if you don‚Äôt like the default implementation. This is the beauty of the protocol oriented approach. üòé</p><h2>Conclusion</h2><p>There is no silver bullet, but if it comes to CRUD, but please <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank">DRY</a>. Using a generic code can be a proper solution, but maybe it won‚Äôt cover every single use case. Taken together I like the fact that I don‚Äôt have to focus anymore on writing API endpoints, but only those that are quite unique. ü§ì</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
