<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>The ultimate Combine framework tutorial in Swift - </title>
    <meta name="description" content="Get started with the brand new declarative Combine framework in practice using Swift. I&#39;ll teach you all the goodies from zero to hero.">
    
    <meta property="og:url" content="/posts/the-ultimate-combine-framework-tutorial-in-swift/">
    <meta property="og:title" content="The ultimate Combine framework tutorial in Swift - ">
    <meta property="og:description" content="Get started with the brand new declarative Combine framework in practice using Swift. I&#39;ll teach you all the goodies from zero to hero.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="The ultimate Combine framework tutorial in Swift - ">
    <meta name="twitter:description" content="Get started with the brand new declarative Combine framework in practice using Swift. I&#39;ll teach you all the goodies from zero to hero.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2017-10-10 16:20:00">2017-10-10 16:20:00</time>
            <h1 class="title">The ultimate Combine framework tutorial in Swift</h1>
            <p class="excerpt">Get started with the brand new declarative Combine framework in practice using Swift. I&#39;ll teach you all the goodies from zero to hero.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h2>What is Combine?</h2><blockquote><p>Customize handling of asynchronous events by combining event-processing operators. - <a href="https://developer.apple.com/documentation/combine/" target="_blank">Apple‚Äôs Combine Framework</a></p></blockquote><p>In other words, it allows you to write functional reactive code in a declarative way using Swift. Functional reactive programming (<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank">FRP</a>) is a special paradigm used to deal with asynchronous code. It‚Äôs a special kind of <a href="https://theswiftdev.com/2019/02/05/beginners-guide-to-functional-swift/" target="_blank">functional programming</a>, where you are working with async streams of values. So basically you can process and transform values over time using functional methods like <code>map</code>, <code>flatMap</code>, etc. <a href="https://www.vadimbulavin.com/swift-combine-framework-tutorial-getting-started/" target="_blank">Combine</a> is the ‚Äúnative‚Äù Swift implementation of this programming paradigm, made by Apple.</p><h2>Publishers, Operators, Subscribers</h2><p>I already made <a href="https://theswiftdev.com/2019/08/15/urlsession-and-the-combine-framework/" target="_blank">a brief networking example of using Combine</a>, which is good if you‚Äôre just looking for a simple code snippet to simplify your URLSession requests. Allow me to grab one example and paste it here again, I‚Äôll show you why‚Ä¶ ü§î</p><pre><code class="language-swift">private var cancellable: AnyCancellable?
//...
self.cancellable = URLSession.shared.dataTaskPublisher(for: url)
.map { $0.data }
.decode(type: [Post].self, decoder: JSONDecoder())
.replaceError(with: [])
.eraseToAnyPublisher()
.sink(receiveValue: { posts in
    print(posts.count)
})
//...
self.cancellable?.cancel()
</code></pre><p>The most important thing here is the new dataTaskPublisher method. It creates Publisher that can send (aka. publish) sequences of values over time.</p><p>Moving forward to the next few lines we can see examples of various Operator functions (<code>map</code>, <code>decode</code>, <code>replaceError</code>, <code>ereaseToAnyPublisher</code>). They are special functional methods and they always return a Publisher. By using operators you can chain a bunch of publishers together, this gives us that nice declarative syntax that I mentioned before. Functional programming is awesome! üòé</p><p>The final member of the Combine family is the Subscriber. Since we can publish all sort of things, we can assume that on the other end of the publisher chain, there will be some sort of object that‚Äôs going to use our final result. Staying with our current example, the sink method is a built-in function that can connect a publisher to a subscriber. You‚Äôll learn the other one later on‚Ä¶ hint: assign.</p><h2>Benefits of using the Combine framework</h2><p>I believe that <a href="https://engineering.q42.nl/swift-combine-framework/" target="_blank">Combine</a> is a huge leap forward and everyone should learn it. My only concern is that you can only use it if you are targeting iOS 13 or above, but this will fade away (in a blink) with time, just like it was with collection and stack views.</p><blockquote><p>Do you remember iOS 6? Yeah, next up: iOS 14!!!</p></blockquote><p>Anyway, there are a bunch of goodies that Combine will bring you:</p><ul><li>Simplified asynchronous code - no more callback hells</li><li>Declarative syntax - easier to read and maintain code</li><li>Composable components - composition over inheritance & reusability</li><li>Multi-platform - except on Linux, we‚Äôre good with SwiftNIO‚Äôs approach</li><li>Cancellation support - it was always an issue with Promises</li><li>Multithreading - you don‚Äôt have to worry about it (that much)</li><li>Built-in memory management - no more bags to carry on</li></ul><p>This is the future of aysnc programming on Apple plaftorms, and it‚Äôs brighter than it was ever before. This is one of the biggest updates since the completely revamped <a href="https://theswiftdev.com/2018/07/10/ultimate-grand-central-dispatch-tutorial-in-swift/" target="_blank">GCD framework API in Swift</a>. Oh, by the way you might ask the question‚Ä¶</p><h2>GCD vs Combine vs Rx vs Promises</h2><p>My advice is to stay with your current favorite solution for about one year (but only if you are happy with it). Learn Combine and be prepared to flip the switch, if the time comes, but if you are just starting a new project and you can go with iOS13+ then I suggest to go with Combine only. You will see how amazing it is to work with this framework, so I if you are still not convinced, it‚Äôs time to‚Ä¶</p><h2>Learn Combine by example</h2><p>Since there are some great articles & books about <a href="https://heckj.github.io/swiftui-notes/" target="_blank">using Combine</a>, I decided to gather only those practical examples and patterns here that I use on a regular basis.</p><h3>Built-in publishers</h3><p>There are just a few built-in publishers in the Foundation framework, but I think the number will grow rapidly. These are the ones that I used mostly to simplify my code:</p><h3>Timer</h3><p>You can use Combine to get periodic time updates through a publisher:</p><pre><code class="language-swift">var cancellable: AnyCancellable?

// start automatically
cancellable = Timer.publish(every: 1, on: .main, in: .default)
.autoconnect()
.sink {
    print($0)
}

// start manually
let timerPublisher = Timer.publish(every: 1.0, on: RunLoop.main, in: .default)
cancellable = timerPublisher
.sink {
    print($0)
}

// start publishing time
let cancellableTimerPublisher = timerPublisher.connect()
// stop publishing time
//cancellableTimerPublisher.cancel()

// cancel subscription
//cancellable?.cancel()
</code></pre><p>You can start & stop the publisher any time you need by using the connect method.</p><blockquote><p>NOTE: Combine has built-in support for cancellation. Both the sink and the assign methods are returning an object that you can store for later and you can call the cancel method on that AnyCancellable object to stop execution.</p></blockquote><h3>NotificationCenter</h3><p>You can also subscribe to notifications by using publishers.</p><pre><code class="language-swift">extension Notification.Name {
    static let example = Notification.Name("example")
}

class ViewController: UIViewController {

    var cancellable: AnyCancellable?

    override func viewDidLoad() {
        super.viewDidLoad()

        self.cancellable = NotificationCenter.Publisher(center: .default, name: .example, object: nil)
        .sink { notification in
            print(notification)
        }

        //post notification
        NotificationCenter.default.post(name: .example, object: nil)
    }
}
</code></pre><p>If you save the cancellable object as a stored property you can retain the subscription until you call the cancel method. Make sure you don‚Äôt make extra retain cycles, so if you need self inside the sink block, always use aweak or unowned reference.</p><h3>URLSession</h3><p>I‚Äôm not going to repeat myself here again, because I already made a complete tutorial about <a href="https://theswiftdev.com/2019/08/15/urlsession-and-the-combine-framework/" target="_blank">how to use URLSession with the Combine framework</a>, so please click the link if you want to learn more about it.</p><p>That‚Äôs it about built-in publishers, let‚Äôs take a look at‚Ä¶</p><h3>Published variables</h3><p><a href="https://nshipster.com/propertywrapper/" target="_blank">Property Wrappers</a> are a brand new feature available from Swift 5.1. Combine comes with one new wrapper called <code>@Published</code>, which can be used to attach a Publisher to a single property. If you mark the property as <code>@Published</code>, you can subscribe to value changes and you can also use these variables as bindings.</p><pre><code class="language-swift">import UIKit
import Combine

class ViewController: UIViewController {

    @IBOutlet weak var textLabel: UILabel!
    @IBOutlet weak var actionButton: UIButton!

    @Published var labelValue: String? = "Click the button!"

    var cancellable: AnyCancellable?

    override func viewDidLoad() {
        super.viewDidLoad()

        self.cancellable = self.$labelValue.receive(on: DispatchQueue.main)
                                           .assign(to: \.text, on: self.textLabel)

    }

    @IBAction func actionButtonTouched(_ sender: UIButton) {
        self.labelValue = "Hello World!"
    }
}
</code></pre><p>By using the <code>$</code> sign and the assign function we can create a binding and subscribe to value changes, so if the labelValue property changes, it‚Äôll be assigned to the text property of the textLabel variable. In other words, the actual text of the label will be updated on the user interface. Also you only want to get updates on the main queue, since we‚Äôre doing UI related stuff. You can use the receive operator for this.</p><h3>Custom publishers</h3><p>Creating a custom publisher is not so hard that you might think, but honestly I never had to make one for myself yet. Still there are some really nice use-cases where building a custom publisher is the right way to go. <a href="https://x.com/twannl" target="_blank">Antoine v.d. SwiftLee</a> has a great tutorial about <a href="https://www.avanderlee.com/swift/custom-combine-publisher/" target="_blank">how to create a custom combine publisher</a> to extend UIKit, you should definitely check that out if you want to learn more about custom publishers.</p><h3>Subjects</h3><p>A subject can be used to transfer values between publishers and subscribers.</p><pre><code class="language-swift">let subject = PassthroughSubject<String, Never>()

let anyCancellable = subject
.sink { value in
    print(value)
}

// sending values to the subject
subject.send("Hello")

// subscribe a subject to a publisher
let publisher = Just("world!")
publisher.subscribe(subject)

anyCancellable.cancel()


// sending errors
enum SubjectError: LocalizedError {
    case unknown
}
let errorSubject = PassthroughSubject<String, Error>()
errorSubject.send(completion: .failure(SubjectError.unknown))
</code></pre><p>You can send values or errors to the subject manually or you can subscribe a publisher to a subject. They are extremely useful if you‚Äôd like to make a Combine-like interface for a traditional delegate pattern based API. Consider the following example as a very basic starting point, but I hope you‚Äôll get the idea. üí°</p><pre><code class="language-swift">class LocationPublisher: NSObject {

    let subject = PassthroughSubject<[CLLocation], Error>()

    //...
}

extension LocationPublisher: CLLocationManagerDelegate {

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        self.subject.send(locations)
    }

    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        self.subject.send(completion: .failure(error))
    }
}
</code></pre><h3>Futures and promises</h3><p>I already have <a href="https://theswiftdev.com/2019/05/28/promises-in-swift-for-beginners/" target="_blank">a tutorial for beginners about promises in Swift</a>, if you need to understand the reasoning behind these types, please read that article first.</p><p>Combine has it‚Äôs own future / promise implementation, which is surprisingly well-made. I use them very often if I have an async callback block, I usually transform that function into a promisified version (returning a publisher), by using a future.</p><pre><code class="language-swift">func asyncMethod(completion: ((String) -> Void)) {
    //...
}

func promisifiedAsyncMethod() -> AnyPublisher<String, Never> {
    Future<String, Never> { promise in
        asyncMethod { value in
            promise(.success(value))
        }
    }
    .eraseToAnyPublisher()
}
</code></pre><h3>Just</h3><p><code>Just</code> is made from a generic <a href="https://theswiftdev.com/2019/01/28/how-to-use-the-result-type-to-handle-errors-in-swift/" target="_blank">result type</a> and a <code>Never</code> failure type. It just provides you a single value, then it will terminate. It‚Äôs quite useful if you want to fallback to a default value, or you just want to return a value.</p><pre><code class="language-swift">let just = Just<String>("just a value")

just.sink(receiveCompletion: { _ in

}) { value in
    print(value)
}
</code></pre><h3>Schedulers</h3><p>You can add a delay to a publisher by using a scheduler, for example if you‚Äôd like to add a 1 second delay, you can use the following snippet:</p><pre><code class="language-swift">return Future<String, Error> { promise in
    promise(.success("example"))
}
.delay(for: .init(1), scheduler: RunLoop.main)
.eraseToAnyPublisher()
</code></pre><h3>Error handling</h3><p>As I mentioned before the <code>Never</code> type is indicates no errors, but what happens if a publisher returns an actual error? Well, you can catch that error, or you can transform the error type into something else by using the <code>mapError</code> operator.</p><pre><code class="language-swift">// error handling in sink
errorPublisher
.sink(receiveCompletion: { completion in
    switch completion {
    case .finished:
        break
    case .failure(let error):
        fatalError(error.localizedDescription)
    }
}, receiveValue: { value in
    print(value)
})


// mapError, catch
_ = Future<String, Error> { promise in
    promise(.failure(NSError(domain: "", code: 0, userInfo: nil)))
}
.mapError { error in
    //transform the error if needed
    return error
}
.catch { error in
    Just("fallback")
}
.sink(receiveCompletion: { _ in

}, receiveValue: { value in
    print(value)
})
</code></pre><p>Of course this is just the tip of the iceberg, you can assert errors and many more, but I hardly use them on a daily basis. Usually I handle my errors in the sink block.</p><h3>Debugging</h3><p>You can use the <code>handleEvents</code> operator to observe emitted events, the other option is to put breakpoints into your chain. There are a few helper methods in order to do this, you should read this <a href="https://www.avanderlee.com/swift/combine-swift/" target="_blank">article about debugging Combine</a> if you want to know more. üëç</p><pre><code class="language-swift">// handle events
.handleEvents(receiveSubscription: { subscription in

}, receiveOutput: { output in

}, receiveCompletion: { completion in

}, receiveCancel: {

}, receiveRequest: { request in

})

// breakpoints
.breakpoint()

.breakpoint(receiveSubscription: { subscription in
    true
}, receiveOutput: { output in
    true
}, receiveCompletion: { completion in
    true
})

.breakpointOnError()
</code></pre><h3>Groups and dependencies</h3><p>I have examples for both cases in my other <a href="https://theswiftdev.com/2019/08/15/urlsession-and-the-combine-framework/" target="_blank">article about Combine & URLSession</a>, so please go and read that if you‚Äôd like to learn how to zip together two publishers.</p><h2>Conclusion</h2><p>Combine is a really nice framework, you should definitively learn it eventually. It‚Äôs also a good opportunity to refactor your legacy / callback-based code into a nice modern declarative one. You can simply transform all your old-school delegates into publishers by using subjects. Futures and promises can help you to move away from callback blocks and prefer publishers instead. There are plenty of <a href="https://heckj.github.io/swiftui-notes/" target="_blank">good resources about Combine</a> around the web, also the official documentation is real good. üìñ</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/hummingbird-routing-and-requests/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2023-03-17 16:20:00">2023-03-17 16:20:00</time>
                    <h2 class="title">Hummingbird routing and requests</h2>
                </section>
                <p>Beginner&#39;s guide to learn all about routing and request handling using the Hummingbird server-side Swift framework.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ¬∑
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ¬∑
                <a href="https://github.com/binarybirds/">GitHub</a> ¬∑
                <a href="https://x.com/tiborbodecs">Twitter</a> ¬∑
                <a href="/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
