<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>AsyncHTTPClient by example - </title>
    <meta name="description" content="This article offers practical examples to introduce the Swift AsyncHTTPClient library.">
    
    <meta property="og:url" content="/posts/async-http-client-by-example/">
    <meta property="og:title" content="AsyncHTTPClient by example - ">
    <meta property="og:description" content="This article offers practical examples to introduce the Swift AsyncHTTPClient library.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="AsyncHTTPClient by example - ">
    <meta name="twitter:description" content="This article offers practical examples to introduce the Swift AsyncHTTPClient library.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2024-04-03 18:30:00">2024-04-03 18:30:00</time>
            <h1 class="title">AsyncHTTPClient by example</h1>
            <p class="excerpt">This article offers practical examples to introduce the Swift AsyncHTTPClient library.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <p>Swift <a href="https://github.com/swift-server/async-http-client" target="_blank">AsyncHTTPClient</a> is an HTTP client library built on top of SwiftNIO. It provides a solid solution for efficiently managing HTTP requests by leveraging the Swift Concurrency model, thus simplifying networking tasks for developers.</p><p>The library’s asynchronous and non-blocking request methods ensure that network operations do not hinder the responsiveness of the application. Additionally, the library offers TLS support, automatic HTTP/2 over HTTPS and several other convenient features.</p><p>The AsyncHTTPClient library is a comprehensive tool for seamless HTTP communication for server-side Swift applications. Throughout this article, we’ll delve into practical <a href="https://github.com/swift-on-server/async-http-client-by-example-sample" target="_blank">examples</a> to showcase the capabilities of this library.</p><h2>Setting up & configuring AsyncHTTPClient</h2><p>Starting with this article, you can utilize a foundational code example as a starting point for integrating the Swift AsyncHTTPClient library into your Swift projects.</p><p>Now, open the <code>Package.swift</code> file in your project directory and add AsyncHTTPClient as a dependency:</p><pre><code class="language-swift">// swift-tools-version: 5.10
import PackageDescription

let package = Package(
    name: "async-http-client-by-example-sample",
    platforms: [
        .macOS(.v14),
    ],
    dependencies: [
        .package(url: "https://github.com/swift-server/async-http-client.git", from: "1.9.0")
    ],
    targets: [
        .executableTarget(
            name: "async-http-client-by-example-sample",
            dependencies: [
                .product(name: "AsyncHTTPClient", package: "async-http-client"),
            ]
        ),
    ]
)
</code></pre><p>In the <code>main.swift</code> file, import the AsyncHTTPClient library and initialize an HTTPClient instance for future use:</p><pre><code class="language-swift">import AsyncHTTPClient

struct Entrypoint {
    
    static func main() async throws {

        let httpClient = HTTPClient(
            // 1.
            eventLoopGroupProvider: .singleton,
            // 2.
            configuration: .init(
                // 3.
                redirectConfiguration: .follow(
                    max: 3,
                    allowCycles: false
                ),
                // 4.
                timeout: .init(
                    connect: .init(.seconds(1)),
                    read: .seconds(1),
                    write: .seconds(1)
                )
            )
        )
        
        do {
            // perform HTTP operations
        }
        catch {
            print("\(error)")
        }

        // 5.
        try await httpClient.shutdown()
    }
}
</code></pre><ol><li>Specify the event loop group provider as `.singleton`, which manages the underlying event loops for asynchronous operations.</li><li>The configuration parameter is set, defining various aspects of the HTTP client’s behavior.</li><li>`redirectConfiguration` is specified to follow redirects up to a maximum of 3 times and disallow redirect cycles.</li><li>Set timeouts for different phases of the HTTP request process, such as connection establishment, reading, and writing.</li><li>Cleanup by calling the `shutdown()` method on the HTTPClient instance.</li></ol><p>Please be aware that it is essential to properly terminate the HTTP client after executing requests. Forgetting to invoke the <code>shutdown()</code> method may cause the library to issue a warning about a potential memory leak when compiling the application in debug mode.</p><h2>Performing HTTP requests</h2><p>An HTTP request includes the method, a URL, headers providing supplementary details, and optionally, a body containing data transmitted to the server. Conversely, HTTP responses contain a status code, headers providing further details, and a body containing the actual content of the response. Together, these components facilitate the exchange of data between clients and servers over the HTTP protocol.</p><p>Below is an illustration of how to employ the HTTP request and response objects using the AsyncHTTPClient library in Swift:</p><pre><code class="language-swift">let httpClient = HTTPClient(eventLoopGroupProvider: .singleton)

do {
    // 1.
    var request = HTTPClientRequest(url: "https://httpbin.org/post")
    // 2.
    request.method = .POST
    // 3.
    request.headers.add(name: "User-Agent", value: "Swift AsyncHTTPClient")
    // 4.
    request.body = .bytes(ByteBuffer(string: "Some data"))
    
    // 5.
    let response = try await httpClient.execute(request, timeout: .seconds(5))
    
    // 6.
    if response.status == .ok {
        // 7.
        let contentType = response.headers.first(name: "content-type")

        // 8.
        let contentLength = response.headers.first(
            name: "content-length"
        ).flatMap(Int.init)

        // 9.
        let buffer = try await response.body.collect(upTo: 1024 * 1024)

        // 10.
        let rawResponseBody = buffer.getString(
            at: 0,
            length: buffer.readableBytes
        )
    }
}
catch {
    print("\(error)")
}

try await httpClient.shutdown()
</code></pre><ol><li>A new HTTP request object is created targeting the specified URL.</li><li>The HTTP request method is set to POST.</li><li>A `user-agent` header with the value `Swift AsyncHTTPClient` is added to the request.</li><li>The request body is set to contain the string “Some data”.</li><li>The request is executed with a custom timeout of 5 seconds.</li><li>If the response status is `.ok` (`200`), further processing is performed.</li><li>The `content-type` of the response is retrieved from the headers.</li><li>The `content-length` of the response is obtained from the headers, as an `Int` value.</li><li>The response body is collected asynchronously, up to a maximum of 1 MiB in size.</li><li>The raw response body is retrieved as a string for further processing.</li></ol><p>Any errors encountered during the execution of the request are caught and printed. If the response body exceeds the 1 MiB limit, a <code>NIOTooManyBytesError</code> error will occur.</p><p>Finally, the HTTP client is shut down to release associated resources.</p><h2>JSON requests</h2><p>JSON requests involve sending and receiving data formatted in JSON to a server. REST API is a style for building networked apps where resources are managed using regular HTTP methods, and the data is encoded and decoded using the JSON format.</p><p>The following code snippet demonstrates how to encode request bodies and decode response bodies using JSON objects:</p><pre><code class="language-swift">// 1.
struct Input: Codable {
    let id: Int
    let title: String
    let completed: Bool
}

struct Output: Codable {
    let json: Input
}


let httpClient = HTTPClient(
    eventLoopGroupProvider: .singleton
)
do {
    // 2.
    var request = HTTPClientRequest(
        url: "https://httpbin.org/post"
    )
    request.method = .POST
    request.headers.add(name: "content-type", value: "application/json")
    
    // 4.
    let input = Input(
        id: 1,
        title: "foo",
        completed: false
    )

    let encoder = JSONEncoder()
    let data = try encoder.encode(input)
    let buffer = ByteBuffer(bytes: data)
    request.body = .bytes(buffer)
    
    let response = try await httpClient.execute(
        request,
        timeout: .seconds(5)
    )
    
    if response.status == .ok {
        // 5.
        if let contentType = response.headers.first(
            name: "content-type"
        ), contentType.contains("application/json") {
            // 6.
            var buffer: ByteBuffer = .init()
            for try await var chunk in response.body {
                buffer.writeBuffer(&chunk)
            }
            
            // 7.
            let decoder = JSONDecoder()
            if let data = buffer.getData(at: 0, length: buffer.readableBytes) {
                let output = try decoder.decode(Output.self, from: data)
                print(output.json.title)
            }
        }

    }
    else {
        print("Invalid status code: \(response.status)")
    }
}
catch {
    print("\(error)")
}

try await httpClient.shutdown()
</code></pre><ol><li>Two `Codable` structures are defined: `Input` for the data to be sent and `Output` for receiving the JSON response.</li><li>An HTTP request is created using a POST method and a `content-type: application/json` header.</li><li>The `Input` data is encoded into JSON data using a `ByteBuffer` and set as the request body.</li><li>If the response status is ok and the content type is JSON, the response body is processed.</li><li>The response body chunks are collected asynchronously and concatenated into a single buffer.</li><li>The buffer containing the JSON data response is decoded as an `Output` structure using.</li></ol><p>The code snippet above demonstrates how to use Swift’s Codable protocol to handle JSON data in HTTP communication. It defines structures for input and output data, sends a POST request with JSON payload, and processes the response by decoding JSON into a designated output structure.</p><h2>File downloads</h2><p>The AsyncHTTPClient library provides support for file downloads using the <code>FileDownloadDelegate</code>. This feature enables asynchronous streaming of downloaded data while simultaneously reporting the download progress, as demonstrated in the following example:</p><pre><code class="language-swift">let httpClient = HTTPClient(
    eventLoopGroupProvider: .singleton
)

do {
    // 1.
    let delegate = try FileDownloadDelegate(
        // 2.
        path: NSTemporaryDirectory() + "600x400.png",
        // 3.
        reportProgress: {
            if let totalBytes = $0.totalBytes {
                print("Total: \(totalBytes).")
            }
            print("Downloaded: \($0.receivedBytes).")
        }
    )
    
    // 4.
    let fileDownloadResponse = try await httpClient.execute(
        request: .init(
            url: "https://placehold.co/600x400.png"
        ),
        delegate: delegate
    ).futureResult.get()
    
    print(fileDownloadResponse)
}
catch {
    print("\(error)")
}

try await httpClient.shutdown()
</code></pre><ol><li>A `FileDownloadDelegate` is created to manage file downloads.</li><li>Specify the download destination path.</li><li>A progress reporting function is provided to monitor the download progress.</li><li>The file download request is executed using the request URL and the delegate.</li></ol><p>Running this example will display the download progress, indicating the received bytes and the total bytes, with the same information also available within the <code>fileDownloadResponse</code> object.</p><p>There are many more configuration options available for the Swift AsyncHTTPClient library. It is also possible to create custom delegate objects; additional useful examples and code snippets are provided in the project’s <a href="https://github.com/swift-server/async-http-client" target="_blank">README on GitHub</a>.</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/async-http-client-by-example/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2024-04-03 18:30:00">2024-04-03 18:30:00</time>
                    <h2 class="title">AsyncHTTPClient by example</h2>
                </section>
                <p>This article offers practical examples to introduce the Swift AsyncHTTPClient library.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ·
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ·
                <a href="https://github.com/binarybirds/">GitHub</a> ·
                <a href="https://x.com/tiborbodecs">Twitter</a> ·
                <a href="/rss.xml" target="_blank">RSS</a> ·
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
