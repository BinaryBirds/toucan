<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Building an HTTP client using SwiftNIO - </title>
    <meta name="description" content="Learn how to build a simple HTTP client using SwiftNIO and structured concurrency.">
    
    <meta property="og:url" content="/posts/building-swiftnio-clients/">
    <meta property="og:title" content="Building an HTTP client using SwiftNIO - ">
    <meta property="og:description" content="Learn how to build a simple HTTP client using SwiftNIO and structured concurrency.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Building an HTTP client using SwiftNIO - ">
    <meta name="twitter:description" content="Learn how to build a simple HTTP client using SwiftNIO and structured concurrency.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2024-02-20 18:30:00">2024-02-20 18:30:00</time>
            <h1 class="title">Building an HTTP client using SwiftNIO</h1>
            <p class="excerpt">Learn how to build a simple HTTP client using SwiftNIO and structured concurrency.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h1>Building a SwiftNIO HTTP client</h1><p>In the previous <a href="/using-swiftnio-channels">SwiftNIO tutorial</a>, you learned how to use SwiftNIO to build a simple TCP echo server. In this tutorial, you’ll build a simple HTTP client using SwiftNIO.</p><p>We’ll use the <code>NIOHTTP1</code> package for parsing and serializing HTTP messages. In addition, SwiftNIO’s structured concurrency is used to manage the lifecycle of our client.</p><p>By the end of this tutorial, you’ll know how to configure a SwiftNIO Channel’s pipeline, and are able to send HTTP requests to a server.</p><p><a href="https://github.com/swift-on-server/building-swiftnio-clients-sample" target="_blank">Download the Samples</a> to get started. It has a dev container for a quick start.</p><blockquote><p>Note: This tutorial will emit some <code>Sendable</code> warnings. These are expected, and should be resolved in a production ready client implementation. However, for the purposes of this tutorial, ignore them.</p></blockquote><h2>Creating a Client Channel</h2><p>In SwiftNIO, Channels are created through a bootstrap. For TCP clients, you’d generally use a <code>ClientBootstrap</code>. There are alternative clients as well, such as Apple’s Transport Services for Apple platforms. In addition, the <code>NIOHTTP1</code> module is used to simplify the process of creating a client channel.</p><p>Add these dependencies to your executable target in your <code>Package.swift</code> file:</p><pre><code class="language-swift">.executableTarget(
    name: "swift-nio-part-3",
    dependencies: [
        .product(name: "NIO", package: "swift-nio"),
        .product(name: "NIOHTTP1", package: "swift-nio"),
    ]
),
</code></pre><p>Now, let’s create a <code>ClientBootstrap</code> and configure it to use the <code>NIOHTTP1</code> module’s handlers. First, import the necessary modules:</p><pre><code class="language-swift">import NIOCore
import NIOPosix
import NIOHTTP1
</code></pre><p>Then, create a <code>ClientBootstrap</code>:</p><pre><code class="language-swift">// 1
let httpClientBootstrap = ClientBootstrap(group: NIOSingletons.posixEventLoopGroup)
    // 2
    .channelOption(ChannelOptions.socketOption(.so_reuseaddr), value: 1)
    // 3
    .channelInitializer { channel in
        // 4
        channel.pipeline.addHTTPClientHandlers(
            position: .first,
            leftOverBytesStrategy: .fireError
        )
    }
</code></pre><p>This code prepares a template for creating a client channel. Let’s break it down:</p><ol><li>Create a `ClientBootstrap` using the `NIOSingletons.posixEventLoopGroup` as the event loop group. This is a shared event loop group that can be reused across multiple components of our application.</li><li>NIO Channels can have options set on them. Here, the `SO_REUSEADDR` option is set to `1` to allow the reuse of local addresses.</li><li>Then, provide an initializer that is used to configure the pipeline of newly created channels.</li><li>Finally, the `channelInitializer` adds the necessary HTTP client handlers to the channel’s pipeline. This uses a helper function provided by NIOHTTP1.</li></ol><h2>Creating Types</h2><p>Before creating the HTTP client, it’s necessary to add a few types that are needed for processing HTTP requests and responses.</p><p>When a <code>connect</code> fails, NIO already throws an error. There is no need to catch or represent those. However, the HTTP Client might encounter errors when processing the response. Create an enum to represent these errors:</p><pre><code class="language-swift">enum HTTPClientError: Error {
    case malformedResponse
    case unexpectedEndOfStream
}
</code></pre><p>Finally, add an enum to represent the state of processing the response:</p><pre><code class="language-swift">enum HTTPPartialResponse {
    case none
    case receiving(HTTPResponseHead, ByteBuffer)
}
</code></pre><p>The enum if pretty simple, and is not representative of a <em>mature</em> HTTP client implementation such as <a href="https://github.com/swift-server/async-http-client" target="_blank">AsyncHTTPClient</a>. However, it’s enough to get started with building a (TCP) client.</p><h2>Implementing the HTTP Client</h2><p>Now that the necessary types have been created, create the <code>HTTPClient</code> type with a simple function that sends a request and returns the response.</p><pre><code class="language-swift">struct HTTPClient {
    let host: String

    func request(
        _ uri: String,
        method: HTTPMethod = .GET,
        headers: HTTPHeaders = [:]
    ) async throws -> (HTTPResponseHead, ByteBuffer) {
        // 5
        let clientChannel = try await httpClientBootstrap.connect(
            host: host,
            port: 80
        ).flatMapThrowing { channel in
            // 6
            try NIOAsyncChannel(
                wrappingChannelSynchronously: channel,
                configuration: NIOAsyncChannel.Configuration(
                    inboundType: HTTPClientResponsePart.self, // 7
                    outboundType: HTTPClientRequestPart.self // 8
                )
            )
        }.get() // 9

        // TODO: Send request & process response
    }
}
</code></pre><p>Let’s break it down:</p><ol><li>Use the `httpClientBootstrap` to create a new client channel. This returns an `EventLoopFuture` containing a regular NIO `Channel`. By using `flatMapThrowing` to transform the result of this future, it’s possible to convert the `EventLoopFuture` into a `NIOAsyncChannel`.</li><li>In order to use structured concurrency, it’s necessary to wrap the `Channel` in an `NIOAsyncChannel`. The inbound and outbound types must be `Sendable`, and need to be configured to match the pipeline’s input and output. This is based on the handlers added in the bootstrap’s `channelInitializer`.</li><li>The `NIOAsyncChannel` is configured to receive `HTTPClientResponsePart` objects. This is the type that the HTTP client will receive from the server.</li><li>The `NIOAsyncChannel` is configured to send `SendableHTTPClientRequestPart` objects. This is the type that the HTTP client will send to the server.</li><li>The `get()` method is called to await for the result of the `EventLoopFuture`.</li></ol><h3>Sending a Request</h3><p>In place of the TODO comment, add the code to send a request and process the response. First, create a <code>HTTPRequestHead</code>. Note that this function does not currently support sending a body with the request. Do so by adding the following code:</p><pre><code class="language-swift">// 10
return try await clientChannel.executeThenClose { inbound, outbound in
    // 11
    let requestHead = HTTPRequestHead(version: .http1_1, method: method, uri: uri, headers: headers)
    try await outbound.write(.head(requestHead))
    try await outbound.write(.end(nil))

    // TODO: Process response
}
</code></pre><p>This is a structured concurrency block that sends the request:</p><ol><li>The `executeThenClose` method is used to obtain a read and write half of the channel. This function returns the result of it’s trailing closure.</li><li>The writer called `outbound` is used to send the request’s part - the head and ‘end’. This is also where the request’s body would be sent.</li></ol><p>Below that, receive and process the response parts as such:</p><pre><code class="language-swift">var partialResponse = HTTPPartialResponse.none
    
// 12
for try await part in inbound {
    // 13
    switch part {
    case .head(let head):
        guard case .none = partialResponse else {
            throw HTTPClientError.malformedResponse
        }
        
        let buffer = clientChannel.channel.allocator.buffer(capacity: 0)
        partialResponse = .receiving(head, buffer)
    case .body(let buffer):
        guard case .receiving(let head, var existingBuffer) = partialResponse else {
            throw HTTPClientError.malformedResponse
        }

        existingBuffer.writeImmutableBuffer(buffer)
        partialResponse = .receiving(head, existingBuffer)
    case .end:
        guard case .receiving(let head, let buffer) = partialResponse else {
            throw HTTPClientError.malformedResponse
        }

        return (head, buffer)
    }
}

// 14
throw HTTPClientError.unexpectedEndOfStream
</code></pre><p>This sets up a state variable to keep track of the response parts received. It then<br>processes the response parts as they come in:</p><ol><li>A `for` loop is used to iterate over the response parts. This is a structured concurrency block that will continue to run until the channel is closed by the remote, an error is thrown, or a `return` statement ends the function.</li><li>The `part` is matched against the `HTTPClientResponsePart` enum. If the part is a head, it’s stored in the `partialResponse` variable. If the part is a body, it’s appended to the buffer in the `partialResponse` variable. If the part is an end, the `partialResponse` is returned.</li><li>If the loop ends without a return, an error is thrown, since the code was unable to receive a complete response.</li></ol><h2>Using the Client</h2><p>Now that the HTTP client is complete, it’s time to use it. Add the following code to the <code>main.swift</code> file:</p><pre><code class="language-swift">let client = HTTPClient(host: "example.com")
let (response, body) = try await client.request("/", headers: ["Host": "example.com"])
print(response)
print(body.getString(at: 0, length: body.readableBytes)!)
</code></pre><p>This creates a client and sends a GET request to <code>example.com</code>. The response is then printed to the console.</p><p>If everything is set up correctly, you should see roughly the following output:</p><pre><code>HTTPResponseHead { version: HTTP/1.1, status: 200 OK, headers: [("Accept-Ranges", "bytes"), ("Age", "464157"), ("Cache-Control", "max-age=604800"), ("Content-Type", "text/html; charset=UTF-8"), ("Date", "Wed, 07 Feb 2024 21:22:33 GMT"), ("Etag", "\"3147526947\""), ("Expires", "Wed, 14 Feb 2024 21:22:33 GMT"), ("Last-Modified", "Thu, 17 Oct 2019 07:18:26 GMT"), ("Server", "ECS (dce/26CD)"), ("Vary", "Accept-Encoding"), ("X-Cache", "HIT"), ("Content-Length", "1256")] }
<!doctype html>
<html>
<head>
    <title>Example Domain</title>

    <meta charset="utf-8" />
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type="text/css">
    ....
</code></pre><p>And that’s it! You’ve built a simple HTTP client using SwiftNIO. You can now use this client to send requests to any server that supports HTTP/1.1.</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/async-http-client-by-example/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2024-04-03 18:30:00">2024-04-03 18:30:00</time>
                    <h2 class="title">AsyncHTTPClient by example</h2>
                </section>
                <p>This article offers practical examples to introduce the Swift AsyncHTTPClient library.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ·
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ·
                <a href="https://github.com/binarybirds/">GitHub</a> ·
                <a href="https://x.com/tiborbodecs">Twitter</a> ·
                <a href="/rss.xml" target="_blank">RSS</a> ·
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
