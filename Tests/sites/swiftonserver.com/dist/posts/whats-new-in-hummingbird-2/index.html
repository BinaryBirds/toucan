<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>What&#39;s new in Hummingbird 2? - </title>
    <meta name="description" content="Discover Hummingbird 2: a Swift-based HTTP server framework, with modern concurrency and customizable request contexts.">
    
    <meta property="og:url" content="/posts/whats-new-in-hummingbird-2/">
    <meta property="og:title" content="What&#39;s new in Hummingbird 2? - ">
    <meta property="og:description" content="Discover Hummingbird 2: a Swift-based HTTP server framework, with modern concurrency and customizable request contexts.">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="What&#39;s new in Hummingbird 2? - ">
    <meta name="twitter:description" content="Discover Hummingbird 2: a Swift-based HTTP server framework, with modern concurrency and customizable request contexts.">
    
    <link rel="stylesheet" href="/css/global.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">

    <link rel="shortcut icon" href="/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-touch-icon-180x180.png">

</head>

<body>
    <header id="navigation">
        <a id="site-logo" href="">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
        </a>
    
        <nav id="primary-menu">
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/">Home</a>
                <a href="/blog/">Blog</a>
                <a href="/posts/pages/1/">Posts</a>
                <a href="/authors/">Authors</a>
                <a href="/tags/">Tags</a>
                <a href="/my-page/">My page</a>
            </div>
        </nav>
    
        <nav id="secondary-menu">
            <input type="checkbox" id="secondary-menu-button" name="menu-button" class="menu-button">
            <label for="secondary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="1"></circle>
                    <circle cx="12" cy="5" r="1"></circle>
                    <circle cx="12" cy="19" r="1"></circle>
                </svg>
            </label>
            <div class="menu-items right">
                <a href="#">My account</a>
                <a href="/">Logout</a>
            </div>
        </nav>
    </header>
        
    <main>

<article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2024-02-27 18:30:00">2024-02-27 18:30:00</time>
            <h1 class="title">What&#39;s new in Hummingbird 2?</h1>
            <p class="excerpt">Discover Hummingbird 2: a Swift-based HTTP server framework, with modern concurrency and customizable request contexts.</p>
        </section>
        
    </header>

    <section id="contents" class="content-wrapper">
    
    <h1>What’s new in Hummingbird 2?</h1><p><a href="https://github.com/hummingbird-project/hummingbird" target="_blank">Hummingbird</a> is a lightweight, flexible HTTP server framework written in Swift. The work on the second major version started last year and the first alpha version was tagged on the 22th of January, 2024. There are quite a lot of significant changes and under the hood improvements. It seems like the new APIs are mostly settled down at this point, so this is a great opportunity to introduce HB2. Let’s dive in.</p><h2>Swift concurrency</h2><p>Hummingbird 2 was built using the modern Swift concurrency APIs. Most of the NIO event loop references are replaced with async / await functions and calls. Structured concurrency is present all around the codebase and the project components, such as <code>HBRequest</code>, are thread safe thanks to the <code>Sendable</code> conformance.</p><p>Before the async / await feature adoption, some components had a <code>HBAsync</code> prefix. Those are now removed from the v2 library. For example<code>HBAsyncMiddleware</code> is now <code>MiddlewareProtocol</code> or <code>HBAsyncResponder</code> is simply called <code>HTTPResponder</code>.</p><p>It is worth to mention that HB2 is prepared for Swift 6, the project also compiles against the experimental <code>StrictConcurrency=complete</code> feature flag.</p><h2>Swift service lifecycle v2</h2><p>The <a href="https://github.com/swift-server/swift-service-lifecycle" target="_blank">Swift service lifecycle library</a> provides a clean startup and shutdown mechanism for server applications. Hummingbird 2 uses the latest version of the library including support for graceful shutdown even for custom application services. When Hummingbird is signalled by swift-service-lifecycle to gracefully shut down, any currently running requests continue being handled. New connections and requests will not be accepted, and idle connections are shut down. Once everything’s ready, Hummingbird will shut down completely.</p><h2>Hummingbird core and foundation</h2><p>The <a href="https://github.com/hummingbird-project/hummingbird-core" target="_blank">HummingbirdCore</a> repository is merged into main repository. The <code>HummingbirdFoundation</code> target was also removed and now all the Foundation extensions are part of the main Hummingbird Swift package target. This makes Hummingbird ergonomically closer to Vapor, allowing users to get started more quickly. This decision is backed by the upcoming move to the new swift-foundation library.</p><h2>Jobs framework updates</h2><p>The HummingbirdJobs framework can be used to push work onto a queue, so that is  processed outside of a request. Job handlers were restructured to use <code>TaskGroup</code> and conform to the <code>Service</code> protocol from the Swift service lifecycle framework. A <code>JobQueue</code> can also define it’s own <code>JobID</code> type, which helps when integrating with various database/driver implementations.</p><h2>Connection pools</h2><p>The custom connection pool implementation was removed from the framework. Previously, this component offered connection pooling for PostgreSQL. Since <a href="https://github.com/vapor/postgres-nio" target="_blank">PostgresNIO</a> has built-in support, there’s no need for it anymore inside the HB framework.</p><h2>HTTP improvements</h2><p>Hummingbird 2 takes advantage of the brand new <a href="https://github.com/apple/swift-http-types" target="_blank">Swift HTTP Types library</a>. The overall support for HTTP2 and TLS is also improved a lot in the second major version.</p><h2>Router library</h2><p>Hummingbird 2 features a brand new routing library, based on Swift result builders. This is a standalone project, the old route building mechanism still works, but if you prefer result builders you can try the new method by importing this lib.</p><p>Here’s a little sneak-peak about the usage of the new <code>RouterBuilder</code> object:</p><pre><code class="language-swift">import HummingbirdRouter

let router = RouterBuilder(context: BasicRouterRequestContext.self) {
    TestEndpointMiddleware()
    Get("test") { _, context in
        return context.endpointPath
    }
    Get { _, context in
        return context.endpointPath
    }
    Post("/test2") { _, context in
        return context.endpointPath
    }
}
let app = Application(responder: router)
</code></pre><p>There are more examples available inside the Hummingbird <a href="https://github.com/hummingbird-project/hummingbird/blob/2.x.x/Tests/HummingbirdRouterTests/RouterTests.swift" target="_blank">RouterTests</a> file. If you are curious about the new route builder tool, that’s a good place to get started, since there are no official docs just yet.</p><h2>Generic request context</h2><p>The biggest change to the framework is definitely the introduction of the generic request context. Hummingbird 2.0 separates contextual objects from the <code>Request</code> type and users can define custom properties as custom <code>RequestContext</code> protocol implementations.</p><p>The request context is associated with the reworked <em>Router</em>, which a generic class, featuring a <em>Context</em> type. The <code>BasicRequestContext</code> type is the default <em>Context</em> implementation for the <em>Router</em>. The request decoder and encoder defaults to a JSON-based solution when using the base context. You can provide a custom decoder through a custom router context.</p><p>Let me show you how this new contextual router system works in practice.</p><h2>HB2 example project</h2><p>This article contains a sample project, which you can download from the following <a href="https://github.com/swift-on-server/whats-new-in-hummingbird-2-sample" target="_blank">link</a>.</p><p>You can integrate Hummingbird 2 by adding it as a dependency to your project, using Swift Package Manager.</p><pre><code class="language-swift">// swift-tools-version:5.9
import PackageDescription

let package = Package(
    name: "whats-new-in-hummingbird-2-sample",
    platforms: [
        .macOS(.v14),
    ],
    dependencies: [
        .package(url: "https://github.com/hummingbird-project/hummingbird.git", from: "2.0.0-beta.1"),
        .package(url: "https://github.com/apple/swift-argument-parser.git", from: "1.0.0"),
    ],
    targets: [
        .executableTarget(
            name: "App",
            dependencies: [
                .product(name: "ArgumentParser", package: "swift-argument-parser"),
                .product(name: "Hummingbird", package: "hummingbird"),
                // .product(name: "HummingbirdRouter", package: "hummingbird"),
            ]
        ),
        .testTarget(
            name: "AppTests",
            dependencies: [
                .target(name: "App"),
                .product(name: "HummingbirdXCT", package: "hummingbird"),
            ]
        ),
    ]
)
</code></pre><p>Here’s how to build a custom decoder to handle different media types on your backend server:</p><pre><code class="language-swift">import Hummingbird

// 1.
struct MyRequestDecoder: RequestDecoder {

    func decode<T>(
        _ type: T.Type,
        from request: Request,
        context: some BaseRequestContext
    ) async throws -> T where T: Decodable {
        // 2.
        guard let header = request.headers[.contentType] else {
            throw HTTPError(.badRequest)
        }
        // 3.
        guard let mediaType = MediaType(from: header) else {
            throw HTTPError(.badRequest)
        }
        // 4.
        let decoder: RequestDecoder
        switch mediaType {
        case .applicationJson:
            decoder = JSONDecoder()
        case .applicationUrlEncoded:
            decoder = URLEncodedFormDecoder()
        default:
            throw HTTPError(.badRequest)
        }
        // 5
        return try await decoder.decode(
            type,
            from: request,
            context: context
        )
    }
}

</code></pre><ol><li>Define the custom decoder by implementing the `RequestDecoder` protocol.</li><li>Make sure that the incoming request has a `Content-Type` HTTP header field.</li><li>Construct a valid `MediaType` object from the header field.</li><li>Setup a custom decoder based on the media type.</li><li>Return the decoded object using the decoder, with the request and the context.</li></ol><p>To use the custom decoder, let’s define a custom request context. A request context is a container for the Hummingbird framework to store information needed by the framework. The following snippet demonstrates how to build one using the <em>RequestContext</em> protocol:</p><pre><code class="language-swift">// 1.
protocol MyRequestContext: RequestContext {
    var myValue: String? { get set }
}

// 2.
struct MyBaseRequestContext: MyRequestContext {
    var coreContext: CoreRequestContext

    // 3.
    var myValue: String?

    init(
        channel: Channel,
        logger: Logger = .init(label: "my-request-context")
    ) {
        self.coreContext = .init(
            allocator: channel.allocator,
            logger: logger
        )
        self.myValue = nil
    }
    
    // 4.
    var requestDecoder: RequestDecoder {
        MyRequestDecoder()
    }
}
</code></pre><ol><li>Define a custom `MyRequestContext` protocol using the RequestContext protocol.</li><li>Implement the `MyRequestContext` protocol using a `MyBaseRequestContext` struct.</li><li>Implement custom properties, configure them using the init method, if needed.</li><li>Return the custom `MyRequestDecoder` as a default request decoder implementation.</li></ol><p>The <a href="https://github.com/hummingbird-project/hummingbird-auth" target="_blank">HummingbirdAuth</a> library also defines a custom context (<code>AuthRequestContext</code>) in a similar way to store user auth information.</p><p>It is possible to compose multiple protocols such as <em>AuthRequestContext</em> by conforming to all of them. This makes it easy to integrate the context with various libraries. This also allows libraries to provide middleware that accept a custom context as input, or that modify a custom context, to enrich requests. For example, enriching a request by adding the authenticated user.</p><p>Create the application instance using the <code>buildApplication</code> function.</p><pre><code class="language-swift">import Foundation
import Hummingbird
import Logging

func buildApplication() async throws -> some ApplicationProtocol {
    
    // 1.
    let router = Router(context: MyBaseRequestContext.self)
    
    // 2
    router.middlewares.add(LogRequestsMiddleware(.info))
    router.middlewares.add(FileMiddleware())
    router.middlewares.add(CORSMiddleware(
        allowOrigin: .originBased,
        allowHeaders: [.contentType],
        allowMethods: [.get, .post, .delete, .patch]
    ))

    // 3
    router.get("/health") { _, _ -> HTTPResponse.Status in
        .ok
    }

    // 4.
    MyController().addRoutes(to: router.group("api"))

    // 5.
    return Application(
        router: router,
        configuration: .init(
            address: .hostname("localhost", port: 8080)
        )
    )
}

</code></pre><ol><li>Setup the router using the `MyBaseRequestContext` type as a custom context.</li><li>Add middlewares to the router, HB2 has middlewares on the router instead of the app</li><li>Setup a basic health route on the router, simply return with a HTTP status code</li><li>Add routes using the custom controller to the `api` route group</li><li>Build the Application instance using the router and the configuration</li></ol><p>Inside the main entrypoint you can start the server by calling the <code>runService()</code> method:</p><pre><code class="language-swift">import ArgumentParser
import Hummingbird

@main
struct HummingbirdArguments: AsyncParsableCommand {

    func run() async throws {
        // 1..
        let app = try await buildApplication()
        try await app.runService()
    }
}

</code></pre><p>The route handlers in the <code>MyController</code> struct can access of the custom context type.</p><pre><code class="language-swift">struct MyController<Context: MyRequestContext> {

    // 1.
    func addRoutes(
        to group: RouterGroup<Context>
    ) {
        group
            .get(use: list)
            .post(use: create)
    }

    // 2. 
    @Sendable 
    func list(
        _ request: Request,
        context: Context
    ) async throws -> [MyModel] {
        [
            .init(title: "foo"),
            .init(title: "bar"),
            .init(title: "baz"),
        ]
    }

    @Sendable 
    func create(
        _ request: Request,
        context: Context
    ) async throws -> EditedResponse<MyModel> {
        // 3.
        // context.myValue
        let input = try await request.decode(
            as: MyModel.self,
            context: context
        )
        return .init(status: .created, response: input)
    }
}
</code></pre><ol><li>Register route handlers using the router group</li><li>Hummingbird is thread-safe, so every route handler should be marked  with `@Sendable` to propagate these thread-safety checks.</li><li>It is possible to access both the request and the context in each route handler.</li></ol><p>As you can see there are quite a lot of changes in the latest version of the Hummingbird framework. The final release date is still unknown, but it is expected to happen within a few months, after the alpha & beta period ends.</p><p>If have questions about Hummingbird, feel free to join the following <a href="https://discord.gg/fkN7FC7QJk" target="_blank">Discord server</a>. You can also get some inspiration from the official <a href="https://github.com/hummingbird-project/hummingbird-examples" target="_blank">Hummingbird examples</a> repository.</p>
        
    </section>
    
    <h2>Next</h2>
    
    <h2>Prev</h2>
        <div class="post card">
            <a href="/posts/async-http-client-by-example/" target="">
                <figure>
                    <picture>
                        <img
                            src=""
                            alt=""
                            title=""
                        >
                    </picture>
                </figure>
                <section>
                    <time datetime="2024-04-03 18:30:00">2024-04-03 18:30:00</time>
                    <h2 class="title">AsyncHTTPClient by example</h2>
                </section>
                <p>This article offers practical examples to introduce the Swift AsyncHTTPClient library.</p>
            </a>
        
            
            
        
        </div>
    
    <h2>Related</h2>
    Empty.
    
    <h2>More by author(s)</h2>
    Empty.

</article>

    </main>

    <footer id="page-footer">
        <section class="content-wrapper">
            <figure>
                <picture>
                    <source
                        srcset="/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="/images/logos/logo.png"
                        alt="Logo of "
                        title=""
                    >
                </picture>
            </figure>
    
            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p>
                <a href="https://binarybirds.com/">Home</a> ·
                <a href="mailto:binarybirdsofficial@gmail.com">Email</a> ·
                <a href="https://github.com/binarybirds/">GitHub</a> ·
                <a href="https://x.com/tiborbodecs">Twitter</a> ·
                <a href="/rss.xml" target="_blank">RSS</a> ·
                <a href="/sitemap.xml" target="_blank">Sitemap</a>
            </p>
    
            <p class="small"> &copy; 2022 - 2024.</p>
        </section>
    </footer>
</body>
</html>
